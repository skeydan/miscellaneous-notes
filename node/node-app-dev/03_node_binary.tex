\documentclass{scrartcl}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{lightcyan}{HTML}{E0FFFF}
\usepackage[colorlinks=true, urlcolor=blue, linkcolor=red]{hyperref}
\usepackage{graphicx}


\begin{document}

    % kudos to: https://github.com/ghammock/LaTeX_Listings_JavaScript_ES6!

    \lstdefinelanguage{JavaScript}{
        morekeywords=[1]{break, continue, delete, else, for, function, if, in,
            new, return, this, typeof, var, void, while, with},
        % Literals, primitive types, and reference types.
        morekeywords=[2]{false, null, true, boolean, number, undefined,
            Array, Boolean, Date, Math, Number, String, Object},
        % Built-ins.
        morekeywords=[3]{eval, parseInt, parseFloat, escape, unescape},
        sensitive,
        morecomment=[s]{/*}{*/},
        morecomment=[l]//,
        morecomment=[s]{/**}{*/}, % JavaDoc style comments
        morestring=[b]',
        morestring=[b]"
    }[keywords, comments, strings]

    \lstalias[]{ES6}[ECMAScript2015]{JavaScript}

    \lstdefinelanguage[ECMAScript2015]{JavaScript}[]{JavaScript}{
        morekeywords=[1]{await, async, case, catch, class, const, default, do,
            enum, export, extends, finally, from, implements, import, instanceof,
            let, static, super, switch, throw, try},
        morestring=[b]` % Interpolation strings.
    }

    % Requires package: color.
    \definecolor{mediumgray}{rgb}{0.3, 0.4, 0.4}
    \definecolor{mediumblue}{rgb}{0.0, 0.0, 0.8}
    \definecolor{forestgreen}{rgb}{0.13, 0.55, 0.13}
    \definecolor{darkviolet}{rgb}{0.58, 0.0, 0.83}
    \definecolor{royalblue}{rgb}{0.25, 0.41, 0.88}
    \definecolor{crimson}{rgb}{0.86, 0.8, 0.24}
    \definecolor{lightgreen}{HTML}{F0FFF0}

    \lstdefinestyle{JSES6Base}{
        backgroundcolor=\color{lightgreen},
        basicstyle=\ttfamily,
        breakatwhitespace=false,
        breaklines=false,
        captionpos=b,
        columns=fullflexible,
        commentstyle=\color{mediumgray}\upshape,
        emph={},
        emphstyle=\color{crimson},
        extendedchars=true,  % requires inputenc
        fontadjust=true,
        frame=single,
        identifierstyle=\color{black},
        keepspaces=true,
        keywordstyle=\color{mediumblue},
        keywordstyle={[2]\color{darkviolet}},
        keywordstyle={[3]\color{royalblue}},
        numbers=left,
        numbersep=5pt,
        numberstyle=\tiny\color{black},
        rulecolor=\color{black},
        showlines=true,
        showspaces=false,
        showstringspaces=false,
        showtabs=false,
        stringstyle=\color{forestgreen},
        tabsize=2,
        title=\lstname,
        upquote=true  % requires textcomp
    }

    \lstdefinestyle{JavaScript}{
        language=JavaScript,
        style=JSES6Base
    }

    \lstdefinestyle{ES6}{
        language=ES6,
        style=JSES6Base
    }


\section{The Node Binary}
\subsection{Common Command Line Arguments}

    \begin{lstlisting}[language=bash]
    # only check syntax
    node --check app.js
    node -c app.js

    # evaluate (but don't print)
    node --eval "1+1"
    node -e "console.log(1+1)"
    2
    node -e "console.log(1+1); 0"
    2

    # evaluate and print
    node -e "console.log(1+1)"
    2
    undefined

    node -p "console.log(1+1); 0"
    2
    0
    \end{lstlisting}


\subsection{Module availability}

    All Node core modules can be accessed by their namespaces within the code evaluation context - no require required:

    \begin{lstlisting}[language=bash]
    node -p "fs.readdirSync('.').filter((f) => /.js$/.test(f))"
    []
    \end{lstlisting}

\subsection{Preloading files}

    \begin{lstlisting}[style=ES6]
    // preload.js
    console.log('preload.js: this is preloaded')

    // app.js
    console.log('app.js: this is the main file')
    \end{lstlisting}

    \begin{lstlisting}[language=bash]
    // CommonJS
    node -r ./preload.js app.js
    node --require ./preload.js app.js

    // ES modules
    node --loader ./preload.js app.js
    \end{lstlisting}


\subsection{Stack trace limit}

    By default, only the first 10 stack frames are shown, which can lead to the root cause of the error not being shown.

    In this case, modify the V8 option --stack-trace-limit:

    \begin{lstlisting}[language=bash]
    node --stack-trace-limit=20 file.js
    \end{lstlisting}

\section{Debugging and Diagnostics}

    Start node in debugging mode:

    \begin{lstlisting}[language=bash]
        node --inspect file.js # runs immediately
        node --inspect-brk file.js # breakpoint at start of program
    \end{lstlisting}

\section{Core JavaScript Concepts}
\subsection{Types}

    Everything besides the following primitive types is an object - functions and array, too,s are objects, for example.

    \begin{lstlisting}[style=ES6]
        // The null primitive is typically used to describe
        the absence of an object...
        // Null
        null

        // Undefined
        // ... whereas undefined is the absence
        of a defined value.
        // Any variable initialized without a value will be undefined.
        // Any expression that attempts access of a non-existent
        property on an object will result in undefined.
        // A function without a return statement will return undefined.
        undefined

        // Number
        // The Number type is double-precision floating-point format.
        // It allows both integers and decimals but
        // has an integer range of $-253^-1$ to $253^-1$.
        1, 1.5, -1e4, NaN

        // BigInt
        // The BigInt type has no upper/lower limit on integers.
        1n, 9007199254740993n

        // String
        'str', "str", `str ${var}`

        // Boolean
        true, false

        // Symbol
        // Symbols can be used as unique identifier keys in objects.
        The Symbol.for method creates/gets a global symbol.
        Symbol('description'), Symbol.for('namespace')...

    \end{lstlisting}

    An object is a set of key value pairs, where values can be any primitive type or an object (including functions, since functions are objects). Object keys are called properties.

    All JavaScript objects have prototypes.
    A prototype is an implicit reference to another object that is queried in property lookups.
    If an object doesn't have a particular property, the object's prototype is checked for that property. and so on. This is how inheritance in JavaScript works.

\end{document}




























