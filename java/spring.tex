\documentclass{scrartcl}
\usepackage{listings}
\usepackage{xcolor}
\definecolor{lightcyan}{HTML}{E0FFFF}
\usepackage[colorlinks=true, urlcolor=blue, linkcolor=red]{hyperref}
\usepackage{graphicx}


\begin{document}
    \lstset{
        language=Java,
        numbers=left,
        stepnumber=1,
        numbersep=5pt,
        backgroundcolor=\color{lightcyan},
        showspaces=false,
        showstringspaces=false,
        showtabs=false,
        tabsize=2,
        captionpos=b,
        breaklines=true,
        breakatwhitespace=true,
        title=\lstname,
        basicstyle=\ttfamily
    }

\section{Sources}

\begin{itemize}
    \item \url{https://redips789.github.io/spring-certification/Spring-Certification.html}
    \item \url{https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring}
    \item \url{https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring}


    \item \url{https://www.baeldung.com/spring-bean-names}
    \item \url{https://www.baeldung.com/spring-core-annotations}
    \item \url{https://www.baeldung.com/spring-bean-annotations}
    \item \url{https://www.baeldung.com/spring-component-scanning}
    \item \url{https://www.baeldung.com/spring-annotations-resource-inject-autowire}
    \item \url{https://www.digitalocean.com/community/tutorials/spring-bean-life-cycle}
\end{itemize}

\section{Bean Lifecycle}
\subsection{Overview}

From a bird's eye, everything that happens before a bean is ready to use can be assigned to one of three phases (see fig. \ref{fig:bean-lifecycle-3}):

\begin{itemize}
    \item Loading and maybe modifying bean definitions
    \item Instantiating beans
    \item Initializing beans
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{bean-lifecycle-3}
    \caption{Lifecycle overview}
    \label{fig:bean-lifecycle-3}
\end{figure}

Figure \ref{fig:bean-lifecycle-2} focuses on pre-initialization.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{bean-lifecycle-2}
    \caption{Zooming in on pre-instantiation}
    \label{fig:bean-lifecycle-2}
\end{figure}

On the other hand, fig. \ref{fig:bean-lifecycle-1} zooms in on post-instantiation.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{bean-lifecycle-1}
    \caption{Zooming in on post-instantiation}
    \label{fig:bean-lifecycle-1}
\end{figure}


See https://www.digitalocean.com/community/tutorials/spring-bean-life-cycle for code to display the order of invocations.

\subsubsection{Load bean definitions, creating an ordered graph}
In this step, all the configuration files – @Configuration classes or XML files – are processed. For annotation-based configuration, all the classes annotated with @Components are scanned to load the bean definitions.

Bean definitions are passed to a BeanFactory, each under its id and type. For example, ApplicationContext is a BeanFactory.

Then, BeanFactoryPostProcessors are run.

\subsubsection{Instantiate and run BeanFactoryPostProcessors}
In a Spring application, a BeanFactoryPostProcessor can modify the definition of any bean.
The BeanFactory object is passed as an argument to the postProcess() method of the BeanFactoryPostProcessor. BeanFactoryPostProcessor then works on the bean definitions or the configuration metadata of the bean before the beans are actually created.
Spring provides several useful implementations of BeanFactoryPostProcessor, such as reading properties and registering a custom scope. We can write your own implementation of the BeanFactoryPostProcessor interface. To influence the order in which bean factory post processors are invoked, their bean definition methods may be annotated with the @Order annotation. If you are implementing your own bean factory post processor, the implementation class can also implement the Ordered interface.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{bean-lifecycle-3}
    \caption{}
    \label{fig:bean-lifecycle-1}
\end{figure}

\subsubsection{Instantiate beans}
Injects values and bean references into beans’ properties.

\subsubsection{Call BeanNameAware’s setBeanName() for each bean implementing it}

\subsubsection{Call BeanFactoryAware’s setBeanFactory() passing the bean factory for each bean implementing it}

\subsubsection{Call ApplicationContextAware’s setApplicationContext for each bean implementing it}

\subsubsection{Before initialization: Run pre-initialization BeanPostProcessors}
The Application context calls postProcessBeforeInitialization() for each bean implementing BeanPostProcessor.

\begin{lstlisting}
   public interface BeanPostProcessor {

       /**
       * Apply this {@code BeanPostProcessor} to the given new bean instance before any bean's initialization callbacks (like InitializingBean's afterPropertiesSet
       * or a custom init-method).
       **/
       @Nullable
       default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
           return bean;
       }

       /**
       * Apply this {@code BeanPostProcessor} to the given new bean instance after any bean initialization callbacks (like InitializingBean's afterPropertiesSet
       * or a custom init-method).
       */
       @Nullable
       default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
           return bean;
       }
   }
\end{lstlisting}

In postProcessBeforeInitialization and postProcessAfterInitialization, a bean implementing BeanPostProcessor can return anything it wants - even something completely different!

Figure \ref{fig:custom_bean_postprocessor} shows a no-op implementation.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{custom_bean_postprocessor}
    \caption{Custom bean postprocessor}
    \label{fig:custom_bean_postprocessor}
\end{figure}

\subsubsection{Initialization: Call InitializingBean’s afterPropertiesSet()}
If a bean implements the InitializingBean interface, Spring calls its afterPropertiesSet() method. Used to initialize processes,  load resources, etc. This approach is simple to use but it’s not recommended because it will create tight coupling with the Spring framework in our bean implementations.

\begin{lstlisting}
public interface InitializingBean {

    /**
    * Invoked by the containing BeanFactory after it has set all bean properties.
    * This method allows the bean instance to perform validation of its overall configuration and final initialization when all bean properties have been set.
    */
    void afterPropertiesSet() throws Exception;

}
\end{lstlisting}

\subsubsection{Initialization: Init Method, @PostConstruct}
Instead of implementing InitializingBean, you can use the init-method of the bean tag, the initMethod attribute of the @Bean annotation, and JSR 250's @PostConstruct  annotation.
Here we use the init-method attribute:

\begin{lstlisting}
    <bean name="myEmployeeService" class="com.journaldev.spring.service.MyEmployeeService"
    init-method="init" destroy-method="destroy">
    <property name="employee" ref="employee"></property>
    </bean>
\end{lstlisting}

Using init-method is a solution when you don't own the class (and so, can't annotate it).

And here, the @PostConstruct annotation.

\begin{lstlisting}
    @PostConstruct
    public void init(){
        System.out.println("MyService init method called");
    }
\end{lstlisting}

@PostConstruct and init-method are enabled by Spring's  CommonAnnotationBeanPostProcessor. This is a
BeanPostProcessor implementation that supports common Java annotations out of the box, in particular the JSR-250 annotations in the javax.annotation package.

It includes support for the javax.annotation.PostConstruct and javax.annotation.PreDestroy annotations - as init annotation and destroy annotation, respectively - through inheriting from InitDestroyAnnotationBeanPostProcessor with pre-configured annotation types.

\begin{lstlisting}
    public class CommonAnnotationBeanPostProcessor extends InitDestroyAnnotationBeanPostProcessor
    implements InstantiationAwareBeanPostProcessor, BeanFactoryAware, Serializable {...}

\end{lstlisting}

\subsubsection{After initialization: Run post-initialization BeanPostProcessors}
The application context calls postProcessAfterInitialization() for each bean implementing BeanPostProcessor.

\subsubsection{Bean ready to use}
Your beans remain live in the application context until it is closed by calling the close() method of the application context.

\subsubsection{Custom destruction}
If a bean implements the DisposableBean interface, Spring calls its destroy() method to destroy any process or clean up the resources of your application. There are other methods to achieve this step-for example, you can use the destroy-method of the tag, the destroyMethod attribute of the `@Bean` annotation, and JSR 250's `@PreDestroy` annotation.

\section{Dependency injection}

Note: In addition to bean definitions that contain information on how to create a specific bean, the ApplicationContext implementations also permit the registration of existing objects that are created outside the container (by users).

This is done by accessing the ApplicationContext’s BeanFactory through the \lstinline{getBeanFactory()} method, which returns the \lstinline{DefaultListableBeanFactory} implementation.

DefaultListableBeanFactory supports this registration through the \lstinline{registerSingleton(..)} and \lstinline{registerBeanDefinition(..)} methods.

\subsection{Constructor-based}

    In the case of constructor-based dependency injection, the container will invoke a constructor with arguments each representing a dependency we want to set.
    This is the recommended way.

    \begin{lstlisting}
        @Configuration
        public class AppConfig {
            @Bean
            public Item item1() {
                return new ItemImpl1();
            }
            @Bean
            public Store store() {
                return new Store(item1());
            }
        }
    \end{lstlisting}

    Resp.

    \begin{lstlisting}
        <bean id="item1" class="org.baeldung.store.ItemImpl1" />
        <bean id="store" class="org.baeldung.store.Store">
        <constructor-arg type="ItemImpl1" index="0" name="item" ref="item1" />
        </bean>
    \end{lstlisting}

\subsection{Method-based}

    For setter-based DI, the container will call setter methods of our class after invoking a no-argument constructor or no-argument static factory method to instantiate the bean.

    \begin{lstlisting}
        @Bean
        public Store store() {
            Store store = new Store();
            store.setItem(item1());
            return store;
        }
    \end{lstlisting}

    Resp.

    \begin{lstlisting}
        <bean id="store" class="org.baeldung.store.Store">
        <property name="item" ref="item1" />
        </bean>
    \end{lstlisting}

\subsection{Field-based}

    In field-based DI, we can inject the dependencies by marking them with an @Autowired annotation. (This even works for private fields.)
    Field-based injection is not recommended - e.g., it makes testing harder.

    \begin{lstlisting}
        public class Store {
            @Autowired // deprecated
            private Item item;
        }
    \end{lstlisting}


\section{Configuration: Implicit vs. Explicit}

    Also referred to as Java-based (decoupled) and annotation-based.

    with both types, bean naming works differently - see \ref{sec:bean-naming}.

\subsection{Java-based}

    Takes place completely in @Configuration classes. E.g.,

    \begin{lstlisting}
        @Configuration
        public class MyConfig {
        @Bean
        public AccountRepo AccountRepo(){}
        }
    \end{lstlisting}

\subsection{Annotation-based}

    Bean definition and wiring take place completely in POJOs. For this to work, we need to enable component scanning.

    \begin{lstlisting}
        @Configuration
        @ComponentScan
        public class MyConfig {}

        @Component
       public class AccountRepo {}
    \end{lstlisting}


\section{Annotations}
\subsection{Annotations for dependency injection}
\subsubsection{@Autowired}
    @Autowired marks a dependency which Spring is going to resolve and inject. We can use this annotation with constructor, setter, or field injection. E.g.,

    \begin{lstlisting}
        class Car {
            @Autowired
            Engine engine;
        }
    \end{lstlisting}

    Starting with version 4.3, we don’t need to annotate constructors with @Autowired explicitly unless we declare at least two constructors.

    @Autowired matches by type. If there are several classes matching the required type (e.g., implementing the same interface), @Autowired needs to be supplemented by @Qualifier:

    \begin{lstlisting}
        @Component("Repo1")
        class Repo1 implements Repo {}

        @Component("Repo2")
        class Repo2 implements Repo {}

        @Component
        public class Service1 implements ServiceX {
            public Service1(@Qualifier("Repo2") Repo){}

        }

    \end{lstlisting}

    If there is no @Qualifier given, @Autowired looks for a bean annotated with @Primary. If none exists, Spring will match by bean name ( = bean id).

    Here, Spring will look for a bean named x:

    \begin{lstlisting}
        // constructor injection
        @Autowired
        public MyBean(X x){}

       // method injection
       @Autowired
       public setX(X x){}

       // field injection
       @Autowired
       private X x;
    \end{lstlisting}

\subsubsection{@Bean}

    @Bean marks a factory method which instantiates a Spring bean.

    \begin{lstlisting}
        @Bean
        Engine engine() {
            return new Engine();
        }
    \end{lstlisting}

    Spring calls these methods when a new instance of the return type is required. All methods annotated with @Bean must be in @Configuration classes.


\subsubsection{@Resource}

The @Resource annotation matches by name, type, or qualifier (in this order). It is applicable to setter and field injection.
Here’s an example injecting a field. Note that the bean id and the corresponding reference attribute value must match:

\begin{lstlisting}
    @Configuration
    public class MyAppContext {
        @Bean(name="namedFile")
        public File namedFile() {
            File namedFile = new File("namedFile.txt");
            return namedFile;
        }
    }

    @ContextConfiguration(
    loader=AnnotationConfigContextLoader.class,
    classes= MyAppContext.class)
    public class Xxx {
        @Resource(name="namedFile")
        private File defaultFile;
    }
\end{lstlisting}

\subsubsection{@Inject}

The @Inject annotation matches by type, qualifier, or name (in this order). It is applicable to setter and field injection. With @Inject, the class reference variable's name and the bean name don’t have to match.

To use the @Inject annotation, declare the javax.inject library as a Gradle or Maven dependency.

\begin{lstlisting}
    public class MyAppContext {
        @Bean
        // no bean name specified - method name is used
        public File getSomeFile() {
            File namedFile = new File("namedFile.txt");
            return namedFile;
        }
    }

    @ContextConfiguration(
    loader=AnnotationConfigContextLoader.class,
    classes= MyAppContext.class)
    public class Xxx {
        @Inject
        private File defaultFile;
    }
\end{lstlisting}

\subsubsection{@Value}

    We can use @Value for injecting property values into beans. It’s compatible with constructor, setter, and field injection. E.g.,

    \begin{lstlisting}
        Engine(@Value("8") int cylinderCount) {
            this.cylinderCount = cylinderCount;
        }
    \end{lstlisting}

    This is an alternative to making explicit use of Spring's Environment bean. E.g.

    \begin{lstlisting}
       public DataSource dataSource(
        @Value("${db.driver}") String driver,
        ...
        )
        }
    \end{lstlisting}

\subsubsection{@DependsOn}

    We can use this annotation to make Spring initialize other beans before the annotated one. Usually, this behavior is automatic, based on the explicit dependencies between beans. We only need this annotation when the dependencies are implicit, for example, JDBC driver loading or static variable initialization. E.g.,

     \begin{lstlisting}
        @Bean
        @DependsOn("fuel")
        Engine engine() {
            return new Engine();
        }
    \end{lstlisting}

\subsubsection{@Lazy}

    This annotation behaves differently depending on where exactly we place it.

    \begin{itemize}
        \item In an @Bean-annotated bean factory method, it is used to delay the method call (hence the bean creation)
        \item With an @Configuration class, all contained @Bean methods will be affected
        \item For all other @Component classes,  they will be initialized lazily when so annotated.
        \item @Autowired constructors, setters, and fields will be loaded lazily (via proxy).
    \end{itemize}

    \begin{lstlisting}
        @Configuration
        @Lazy
        class VehicleFactoryConfig {

            @Bean
            @Lazy(false)
            Engine engine() {
                return new Engine();
            }
        }
    \end{lstlisting}

\subsubsection{@Scope}

    @Scope is used to define the scope of a @Component class or a @Bean definition. It can be either singleton, prototype, request, session, globalSession or some cust@Component.

\subsection{Context Configuration Annotations}

\subsubsection{@Import}

    With @import, we can use specific @Configuration classes without component scanning.

    \begin{lstlisting}
        @Import(VehiclePartSupplier.class)
        class VehicleFactoryConfig {}
    \end{lstlisting}

\subsubsection{@ImportResource}

    We can import XML configurations with @ImportResource. We can specify the XML file locations with the locations argument, or with its alias, the value argument:

    \begin{lstlisting}
        @Configuration
        @ImportResource("classpath:/annotations.xml")
        class VehicleFactoryConfig {}
    \end{lstlisting}

\subsubsection{@PropertySource}

    With this annotation, we define property files for application settings.

    \begin{lstlisting}
        @Configuration
        @PropertySource("classpath:/annotations.properties")
        @PropertySource("classpath:/vehicle-factory.properties")
        class VehicleFactoryConfig {}
    \end{lstlisting}

    These properties can be used by Spring's Environment bean, in addition to environment variables and Java system properties.

    Allowed prefixes are classpath:, file:, and http:.

\subsection{Bean annotations}

\subsubsection{@Profile}

    Profiles are a way to group bean definitions, for example:

     \begin{itemize}
        \item dev, test, prod environment
        \item jdbc, jpa [implementations]
    \end{itemize}

   The @Profile annotation may be used in any of the following ways:

   \begin{itemize}
       \item At class level in @Configuration classes.
       \item At class level in classes annotated with @Component or annotated with any other annotation that in turn is annotated with @Component.
       \item On methods annotated with the @Bean annotation.
   \end{itemize}

    To define alternative beans with different profile conditions, use distinct Java method names pointing to the same bean name via the @Bean name attribute:

    \begin{lstlisting}
        @Bean("dataSource")
        @Profile("development")
        public DataSource standaloneDataSource(){

        @Bean("dataSource")
        @Profile("production")
        public DataSource jndiDataSource() throws Exception {}

    \end{lstlisting}

   Spring uses two separate properties when determining which profiles are active, spring.profiles.active and spring.profiles.default:

    \begin{itemize}
       \item If spring.profiles.active is set,  then its value determines which profiles are active.
       \item If spring.profiles.active isn’t set, then Spring looks to spring.profiles.default.
       \item If neither spring.profiles.active nor spring.profiles.default is set, only those beans that aren’t defined as being in a profile are created.
    \end{itemize}

   These properties can be set on the command line:

   \begin{lstlisting}[language=bash]
       -Dspring.profiles.active=embedded.jpa
   \end{lstlisting}

   , programmatically:

   \begin{lstlisting}
       System.setProperty("spring.profiles.active", "embedded.jpa");
   \end{lstlisting}

   , or via an annotation (@ActiveProfiles; integration tests only).


\subsubsection{@ComponentScan}

    The @ComponentScan annotation is used together with @Configuration.

    @ComponentScan can be used with and without arguments.

    Without arguments, @ComponentScan  tells Spring to scan the current package and all of its sub-packages.

    With arguments, @ComponentScan tells which packages or classes to scan. E.g., specifying packages:

    \begin{lstlisting}
        @Configuration
        @ComponentScan(basePackages = "com.baeldung.annotations")
        class VehicleFactoryConfig {}
    \end{lstlisting}

    Or else, specifying classes:

    \begin{lstlisting}
        @Configuration
        @ComponentScan(basePackageClasses = VehicleFactoryConfig.class)
        class VehicleFactoryConfig {}
    \end{lstlisting}

    We can specify multiple package names, using spaces, commas, or semicolons as a separator.

    \begin{lstlisting}
        @ComponentScan(basePackages = "springapp.animals;springapp.flowers")
        @ComponentScan(basePackages = "animals,springapp.flowers")
        @ComponentScan(basePackages = "springapp.animals springapp.flowers")
    \end{lstlisting}

    We could also apply a filter, choosing from a range of filter types. For example:

    \begin{lstlisting}
        @ComponentScan(excludeFilters =
        @ComponentScan.Filter(type=FilterType.REGEX,
        pattern="com\\.baeldung\\.componentscan\\.springapp\\.flowers\\..*"))
    \end{lstlisting}

    Or:
    \begin{lstlisting}
        @ComponentScan(excludeFilters =
        @ComponentScan.Filter(type = FilterType.ASSIGNABLE\_TYPE, value = Rose.class))
    \end{lstlisting}

\subsubsection{@Component}

    @Component is a class-level annotation. During component scan, Spring automatically detects classes annotated with @Component.

    \begin{lstlisting}
        @Component
        class CarUtility {
            // ...
        }
    \end{lstlisting}

    @Repository, @Service, @Configuration, and @Controller are all meta-annotations of (i.e., themselves annotated with) @Component. E.g.,

      \begin{lstlisting}
        @Component
        public @interface Service {}
    \end{lstlisting}

    Spring also automatically picks them up during the component scanning process.


\subsubsection{@Repository}

    \begin{lstlisting}
        @Repository
        class VehicleRepository {
            // ...
        }
    \end{lstlisting}

\subsubsection{@Service}

    \begin{lstlisting}
        @Service
        public class VehicleService {
            // ...
        }
    \end{lstlisting}

\subsubsection{@Controller}

    \begin{lstlisting}
        @Controller
        public class VehicleController {
            // ...
        }
    \end{lstlisting}

\subsubsection{@Configuration}

    Configuration classes can contain bean definition methods annotated with @Bean.

    \begin{lstlisting}
        @Configuration
        class VehicleFactoryConfig {

            @Bean
            Engine engine() {
                return new Engine();
            }

        }
    \end{lstlisting}


\subsection{Spring Boot Annotations}
\subsubsection{@SpringBootApplication}

    This is a combination of three annotations:

    \begin{lstlisting}
        @Configuration
        @EnableAutoConfiguration
        @ComponentScan
    \end{lstlisting}

\subsubsection{@ConfigurationProperties}

    Helps keep configuration clean (see \ref{fig:configurationproperties}).

    This annotation has to be enabled via one of:
    \begin{itemize}
        \item @EnableConfigurationProperties on the application class

        \begin{lstlisting}
         @SpringBootApplication
         @EnableConfigurationProperties(
            ConnectionSettings.class)
         public class App {
             // ...
         }
        \end{lstlisting}

        \item @ConfigurationPropertiesScan  on the application class

        \begin{lstlisting}
         @SpringBootApplication
         @ConfigurationPropertiesScan
         public class App {
             // ...
         }
        \end{lstlisting}

        \item @Component on the configuration class

        \begin{lstlisting}
         @Component
         @ConfigurationProperties(prefix="...")
         public class ConnectionSettings {
             // ...
         }
        \end{lstlisting}

    \end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{configurationproperties}
    \caption{}
    \label{fig:configurationproperties}
\end{figure}

\subsubsection{@ConditionalOnX}

Determine what auto configuration does. For example: @ConditionalOnBean, @ConditionalOnMissingBean, @ConditionalOnClass, @ConditionalOnMissingClass, @ConditionalOnProperty.

For example, @Profile is such a condition.

\subsubsection{RestController}

Includes @Controller and @ResponseBody.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{restcontroller}
    \caption{RestController convenience annotation.}
    \label{fig:restcontroller}
\end{figure}

\subsubsection{Request URI Decomposition: @RequestParam, @PathVariable}

Do implicit type conversion of arguments.

\begin{lstlisting}
    // localhost:8080/account?userid=12345
    @GetMapping("/account")
    public List<Account> list(@RequestParam("userid"} int userid) {}

    // localhost:8080/accounts/12345
    @GetMapping("/accounts/{accountId}")
    public Account find (@PathVariable("accountId"} long id) {}

    // if argument name is missing, will take from the mapping
    // could also have

    // localhost:8080/account?overdrawn=12345
    @GetMapping("/account")
    public List<Account> list(@RequestParam int overdrawn) {}

    // localhost:8080/accounts/12345
    @GetMapping("/accounts/{accountId}")
    public Account find (@PathVariable long id) {}

    // localhost:8080/accounts/12345?overdrawn=true
    @GetMapping("/accounts/{accountId}")
    public Account find (
        @PathVariable long accountId,
        @RequestParam boolean overdrawn
    ) {}



\end{lstlisting}

\subsubsection{@ResponseBody}

Causes Java objects returned by the Controller to be processed by HttpMessageConverters in order to return information to the client in the form requested in the Accept header.

\subsubsection{@ResponseStatus}

    Used to return a status other than 200.

    \begin{lstlisting}
        @ResponseStatus(HttpStatus.NO_CONTENT)
        public void updateOrder(...){}
    \end{lstlisting}

\subsubsection{@RequestBody}

    Used to extract the request body.

\section{Aware Interfaces}

    Indicates that the bean is eligible to be notified by the Spring container through the callback methods.
    A typical use case for BeanNameAware could be acquiring the bean name for logging or wiring purposes. For the BeanFactoryAware it could be the ability to use a spring bean from legacy code.
    In most cases, we should avoid using any of the Aware interfaces, unless we need them. Implementing these interfaces will couple the code to the Spring framework.

\subsection{BeanNameAware}

    Makes the object aware of the bean name defined in the container.

\begin{lstlisting}
    public class MyBeanName implements BeanNameAware {
        @Override
        public void setBeanName(String beanName) {
            System.out.println(beanName);
        }
    }
    @Configuration
    public class Config {
        @Bean(name = "myCustomBeanName")
        public MyBeanName getMyBeanName() {
            return new MyBeanName();
        }
    }
    AnnotationConfigApplicationContext context
    = new AnnotationConfigApplicationContext(Config.class);
    MyBeanName myBeanName = context.getBean(MyBeanName.class);

\end{lstlisting}

\subsection{BeanFactoryAware}

    Provides access to the BeanFactory which created the object.

    \begin{lstlisting}
        public class MyBeanFactory implements BeanFactoryAware {
            private BeanFactory beanFactory;
            @Override
            public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
                this.beanFactory = beanFactory;
            }
            public void getMyBeanName() {
                MyBeanName myBeanName = beanFactory.getBean(MyBeanName.class);
                System.out.println(beanFactory.isSingleton("myCustomBeanName"));
            }
        }
        MyBeanFactory myBeanFactory = context.getBean(MyBeanFactory.class);
        myBeanFactory.getMyBeanName();}
    \end{lstlisting}

\subsection{ApplicationContextAware}
    \begin{lstlisting}
        public class ApplicationContextAwareImpl implements ApplicationContextAware {
            @Override
            public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
                User user = (User) applicationContext.getBean("user");
                System.out.println("User Id: " + user.getUserId() + " User Name :" + user.getName());}}
    \end{lstlisting}


\section{Bean Naming}
\label{sec:bean-naming}
\subsection{Default Bean Naming}
\subsubsection{Class-level ("Annotation-based configuration")}
For an annotation used at the class level (@Component, @Service, @Controller), Spring uses the class name and converts the first letter to lowercase.
Custom names may be configured in the annotation's value attribute.

The type is determined from the annotated class, typically resulting in the actual
implementation class.

    \begin{lstlisting}
        @Service
        public class LoggingService { // bean name = loggingService

        }
    \end{lstlisting}

\subsubsection{Method-level ("Java configuration")}
When in a @Configuration class we use the @Bean annotation on a method, Spring uses the method name for the bean name.

    \begin{lstlisting}
        @Configuration
        public class AuditConfiguration {
            @Bean
            public AuditService audit() {
                return new AuditService();
            }
        }
    \end{lstlisting}

\subsection{Custom naming}

    \begin{lstlisting}
        @Component("myBean")
        public class MyCustomComponent {
        }
    \end{lstlisting}

   Custom names may be configured in @Bean's value attribute.

   The type is determined from the method return type, typically resulting in an interface.

\subsection{Naming Beans With @Bean and @Qualifier}
\subsubsection{@Bean With Value}
    The @Bean annotation is applied at the method level, and by default, Spring uses the method name as a bean name. We can override this using the @Bean annotation.

     \begin{lstlisting}
        @Configuration
        public class MyConfiguration {
            @Bean("beanComponent")
            public MyCustomComponent myComponent() {
                return new MyCustomComponent();
            }
        }
    \end{lstlisting}

\subsubsection{@Qualifier With Value}
    We can also use the @Qualifier annotation to name the bean.

    \begin{lstlisting}
        @Component
        @Qualifier("cat")
        public class Cat implements Animal {
            @Override
            public String name() {
                return "Cat";
            }
        }
        @Component
        @Qualifier("dog")
        public class Dog implements Animal {
            @Override
            public String name() {
                return "Dog";
            }
        }
        @Service
        public class PetShow {
            private final Animal dog;
            private final Animal cat;

            public PetShow (@Qualifier("dog")Animal dog, @Qualifier("cat")Animal cat) {
                this.dog = dog;
                this.cat = cat;
            }
            public Animal getDog() {
                return dog;
            }
            public Animal getCat() {
                return cat;
            }
        }
        \end{lstlisting}

\section{Spring Expression Language vs. Property Evaluation}

    Expressions in @Value annotations are of two types:

    \begin{itemize}
        \item Expressions starting with \$. Such expressions reference a property name in the application’s environment. These expressions are evaluated by the PropertySourcesPlaceholderConfigurer BeanFactoryPostProcessor prior to bean creation and can only be used in @Value annnotations.
        \item Expressions starting with \#.
        These expressions are parsed by a SpEL expression parser, and are evaluated by a SpEL expression instance.
    \end{itemize}

    In some cases, both can be used. For example, property values by default are Strings, but may be converted to primitives implicitly. So, both of these work:

    \begin{lstlisting}
        @Value("${daily.limit}")
        int limit;

        @Value("#{environment['daily.limit']}")
        int limit;
    \end{lstlisting}

    But if computations are to be performed, or object types are required, SpEL has to be used:

    \begin{lstlisting}
        // NO
        @Value("${daily.limit} * 2")

        // instead, do
        @Value("#{new Integer(environment['daily.limit']}) * 2")
    \end{lstlisting}

    To provide defaults, use a colon with property evaluation, and ?: in SpEL.

    \begin{lstlisting}
        @Value("${daily.limit}: 1000")
        int limit;

        @Value("#{environment['daily.limit']} ?: 1000")
        int limit;
    \end{lstlisting}

    In addition to application-defined beans, SpEL can make use of beans implicitly provided by Spring, namely environment, systemProperties, and systemEnvironment.

\section{AOP in Spring}

\subsection{Core AOP Concepts}

\subsubsection{Join Point}

A point during the execution of a program, such as the execution of a method or the handling of an exception.

In Spring AOP, a join point always represents a method execution.


\subsubsection{Point Cut}

An expression that selects one or more join points.

Although Spring supports various AspectJ pointcut designators, the most commonly used one is \lstinline{execution}.

For this designator, the syntax pattern is as follows:

\begin{lstlisting}
    execution(
    modifiers-pattern?
    ret-type-pattern
    declaring-type-pattern.?name-pattern(param-pattern)
    throws-pattern?
    )
\end{lstlisting}

All parts except the returning type pattern (ret-type-pattern in the preceding snippet), the name pattern, and the parameters pattern are optional.

\begin{itemize}
    \item The returning type pattern determines what the return type of the method must be in order for a join point to be matched. * is most frequently used as the returning type pattern. It matches any return type. A fully-qualified type name matches only when the method returns the given type.
    \item  The name pattern matches the method name. You can use the * wildcard as all or part of a name pattern. If you specify a declaring type pattern, include a trailing . to join it to the name pattern component.
    \item The parameters pattern is slightly more complex: () matches a method that takes no parameters, whereas (..) matches any number (zero or more) of parameters. The (*) pattern matches a method that takes one parameter of any type. (*,String) matches a method that takes two parameters. The first can be of any type, while the second must be a String.

\end{itemize}

Examples:

\begin{lstlisting}
// The execution of any public method:
execution(public * *(..))

// The execution of any method with a name that begins with set:
execution(* set*(..))

// The execution of any method defined by the AccountService interface:
execution(* com.xyz.service.AccountService.*(..))

// The execution of any method defined in the service package:
execution(* com.xyz.service.*.*(..))

//The execution of any method defined in the service package or one of its sub-packages:
execution(* com.xyz.service..*.*(..))

// There is one directory between rewards and restaurant.
execution(* rewards.*.restaurant.*.*(..))

// There are 0 or more directories between rewards and restaurant.
execution(* rewards..restaurant.*.*(..))

// There must be at least 1 directory before restaurant.
// omitting the star is not allowed
execution(* *..restaurant.*.*(..))

// Any join point (method execution only in Spring AOP) within the service package:
within(com.xyz.service.*)

// Any join point (method execution only in Spring AOP) within the service package or one of its sub-packages:
within(com.xyz.service..*)

// Any join point (method execution only in Spring AOP) where the proxy implements the AccountService interface:
this(com.xyz.service.AccountService)

// Any join point (method execution only in Spring AOP) where the target object implements the AccountService interface:
target(com.xyz.service.AccountService)

// Any join point (method execution only in Spring AOP) that takes a single parameter and where the argument passed at runtime is Serializable:
args(java.io.Serializable)

// Note that the pointcut given in this example is different from execution(* *(java.io.Serializable)). The args version matches if the argument passed at runtime is Serializable, and the execution version matches if the method signature declares a single parameter of type Serializable.

// Any join point (method execution only in Spring AOP) where the target object has a @Transactional annotation:
@target(org.springframework.transaction.annotation.Transactional)

// Any join point (method execution only in Spring AOP) where the declared type of the target object has an @Transactional annotation:
@within(org.springframework.transaction.annotation.Transactional)

// Any join point (method execution only in Spring AOP) where the executing method has an @Transactional annotation:
@annotation(org.springframework.transaction.annotation.Transactional)

// Any join point (method execution only in Spring AOP) which takes a single parameter, and where the runtime type of the argument passed has the @Classified annotation:
@args(com.xyz.security.Classified)

// Any join point (method execution only in Spring AOP) on a Spring bean named tradeService:
bean(tradeService)

// Any join point (method execution only in Spring AOP) on Spring beans having names that match the wildcard expression *Service:
bean(*Service)
\end{lstlisting}

\subsubsection{Advice}


Code to be executed at a particular join point.
Types:

\begin{itemize}
    \item Before-advice is executed before calling the target method.
    \begin{lstlisting}
        @Before("execution(void set*(*))    \end{lstlisting}
    \item
    After-advice is executed after the target method, whatever its outcome.
    \begin{lstlisting}
        @Before("execution(void set*(*))
    \end{lstlisting}
    \item
    After-returning: executed after the target returns successfully. This advice will never execute if the target throws any exception.
    The return parameter also gives access to the returned object.
    \begin{lstlisting}
        @AfterReturning(value="execution(* service..*(..))", return="reward")
        public void audit(Join Point jp, Reward reward) {
            auditService.logEvent(jp.getSignature() + ": " + reward.toString());
        }
    \end{lstlisting}
    \item
    After-throwing: executed after the target throws an exception.
    Also gives access to the exception.
    \begin{lstlisting}
        // Repositories in any package
        @AfterThrowing(value="execution(* *..Repository.*(..))", throwing="e")
        // also have to match the type of the exception
        public void report(JoinPoint jp, DataAccessException e) {
        mailService.mailFailure(jp.getSignature(), e);
        }
    \end{lstlisting}
    While this advice cannot prevent an exception to be thrown, it can throw a more user-friendly exception instead:
    \begin{lstlisting}
        @AfterThrowing(value="execution(* *..Repository.*(..))", throwing"e")
        public void report(JoinPoint jp, DataAccessException e) {
            mailService.mailFailure(jp.getSignature(), e);
            throw new RewardsException();
        }
    \end{lstlisting}
    \item
    Around: executed two times, before and after invocation of the target method. Must call proceed() to delegate to the target. See \ref{fig:around-advice}.
    \begin{figure}
        \centering
        \includegraphics[width=1\linewidth]{around-advice}
        \caption{Around Advice}
        \label{fig:around-advice}
    \end{figure}

\end{itemize}

\subsubsection{Aspect}

The combination of point cut and advice. The @aspect annotation needs to be explicitly enabled by @EnableAspectJConfiguration set in the context (Config) class.

This will cause an extension of AbstractAutoProxyCreator to run, a BeanPostProcessor that wraps a bean with an AOP proxy. See \ref{fig:autoproxycreator}.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{autoproxycreator}
    \caption{Proxy Creation.}
    \label{fig:autoproxycreator}
\end{figure}

An aspect can get context information by injecting the JoinPoint into the advice. See fig. \ref{fig:AOP-join-point}.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{AOP-join-point}
    \caption{Automatic JoinPoint injection}
    \label{fig:AOP-join-point}
\end{figure}

\begin{lstlisting}
    public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport
    implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware {
        //...

        @Override
        public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {
            Object cacheKey = getCacheKey(beanClass, beanName);

            if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) {
                if (this.advisedBeans.containsKey(cacheKey)) {
                    return null;
                }
                if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {
                    this.advisedBeans.put(cacheKey, Boolean.FALSE);
                    return null;
                }
            }
        }

        @Override
        public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {
            if (bean != null) {
                Object cacheKey = getCacheKey(bean.getClass(), beanName);
                if (this.earlyProxyReferences.remove(cacheKey) != bean) {
                    return wrapIfNecessary(bean, beanName, cacheKey);
                }
            }
            return bean;
        }
    }
\end{lstlisting}

\subsubsection{More Terminology}

\textit{Introduction}
Declaring additional methods or fields on behalf of a type. Spring AOP lets you introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)

\textit{Target object}
An object being advised by one or more aspects. Also referred to as the "advised object". Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object.

\textit{AOP proxy}
An object created by the AOP framework in order to implement the aspect contracts (advice method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic proxy or a CGLIB proxy.

\textit{Weaving}
Linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. \textit{Spring AOP, like other pure Java AOP frameworks}, performs weaving at \textit{runtime}.

\subsection{AOP Proxies}

Spring AOP defaults to using standard\textit{ JDK dynamic proxies} for AOP proxies. This enables any interface (or set of interfaces) to be proxied.

Spring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than interfaces. By default, CGLIB is used if a business object does not implement an interface.

If the target object to be proxied implements at least one interface, a JDK dynamic proxy is used, and all of the interfaces implemented by the target type are proxied. If the target object does not implement any interfaces, a CGLIB proxy is created which is a runtime-generated subclass of the target type.

\subsection{Implications of Using a Proxy}

Here, we create an object instance that calls a method on itself (using this).

\begin{lstlisting}
    public class SimplePojo implements Pojo {

        public void foo() {
            // this next method invocation is a direct call on the 'this' reference
            this.bar();
        }

        public void bar() {
            // some logic...
        }
    }

    public class Main {

        public static void main(String[] args) {
            Pojo pojo = new SimplePojo();
            // this is a direct method call on the 'pojo' reference
            pojo.foo();
        }
    }
\end{lstlisting}

When SimplePojo is proxied, the same call will not result in bar() being intercepted, since bar() is not called on the proxy, but the \lstinline[]|this| reference the object has to itself.

\begin{lstlisting}
    public class Main {

        public static void main(String[] args) {
            ProxyFactory factory = new ProxyFactory(new SimplePojo());
            factory.addInterface(Pojo.class);
            factory.addAdvice(new RetryAdvice());

            Pojo pojo = (Pojo) factory.getProxy();
            // this is a method call on the proxy!
            pojo.foo();
        }
    }
\end{lstlisting}

\subsection{Programmatic Creation of @AspectJ Proxies}

In addition to declaring aspects in your xml configuration by using either aop:config or aop:aspectj-autoproxy, it is also possible to programmatically create proxies that advise target objects.

You can use the org.springframework.aop.aspectj.annotation.AspectJProxyFactory class to create a proxy for a target object that is advised by one or more @AspectJ aspects.

\begin{lstlisting}
    // create a factory that can generate a proxy for the given target object
    AspectJProxyFactory factory = new AspectJProxyFactory(targetObject);

    // add an aspect, the class must be an @AspectJ aspect
    // you can call this as many times as you need with different aspects
    factory.addAspect(SecurityManager.class);

    // you can also add existing aspect instances, the type of the object supplied
    // must be an @AspectJ aspect
    factory.addAspect(usageTracker);

    // now get the proxy object...
    MyInterfaceType proxy = factory.getProxy();
\end{lstlisting}



\section{JPA}
\subsection{Repository Query Language}

Example (see \url{  https://docs.spring.io/spring-data/commons/reference/repositories/query-methods-details.html}):


\begin{lstlisting}
   interface PersonRepository extends Repository<Person, Long> {

       List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);

       // Enables the distinct flag for the query
       List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
       List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);

       // Enabling ignoring case for an individual property
       List<Person> findByLastnameIgnoreCase(String lastname);
       // Enabling ignoring case for all suitable properties
       List<Person> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);

       // Enabling static ORDER BY for a query
       List<Person> findByLastnameOrderByFirstnameAsc(String lastname);
       List<Person> findByLastnameOrderByFirstnameDesc(String lastname);
   }
\end{lstlisting}

\subsection{Reserved Method Names}

    Reserved methods like CrudRepository.findById (or just findById) are targeting the identifier property regardless of the actual property name used in the declared method.
    Example:

\begin{lstlisting}
    class User {
        //The identifier property (primary key).
        @Id Long pk;

        // A property named id, but not the identifier.
        Long id;
    }

    interface UserRepository extends Repository<User, Long> {

        // Targets the pk property (the one marked with @Id which is considered to be the identifier) as it refers to a CrudRepository base repository method.
        Optional<User> findById(Long id);

        // Targets the pk property by name as it is a derived query.
        Optional<User> findByPk(Long pk);

        // Targets the id property by using the descriptive token between find and by to avoid collisions with reserved methods.
        Optional<User> findUserById(Long id);
    }

\end{lstlisting}

\subsection{Paging, Iterating Large Results, Sorting and Limiting}

    Spring recognizes certain specific types like Pageable, Sort and Limit, to apply pagination, sorting and limiting to your queries dynamically.
    Example:

\begin{lstlisting}
    Page<User> findByLastname(String lastname, Pageable pageable);

    Slice<User> findByLastname(String lastname, Pageable pageable);

    List<User> findByLastname(String lastname, Sort sort);

    List<User> findByLastname(String lastname, Sort sort, Limit limit);

    List<User> findByLastname(String lastname, Pageable pageable);
\end{lstlisting}

\subsection{Repository Query Keywords}

\begin{lstlisting}
    // General query method returning typically the repository type, a Collection or Streamable subtype or a result wrapper such as Page, GeoResults or any other store-specific result wrapper. Can be used as findBy..., findMyDomainTypeBy... or in combination with additional keywords.
    find...By, read...By, get...By, query...By, search...By, stream...By

    // Exists projection, returning typically a boolean result.
    exists...By

    // Count projection returning a numeric result.
    count...By

    //  Delete query method returning either no result (void) or the delete count.
    delete...By, remove...By

    //  Limit the query results to the first <number> of results. This keyword can occur in any place of the subject between find (and the other keywords) and by.
    ...First<number>..., ...Top<number>...

    //  Use a distinct query to return only unique results. Consult the store-specific documentation whether that feature is supported. This keyword can occur in any place of the subject between find (and the other keywords) and by.
    ...Distinct...
\end{lstlisting}

\subsection{Supported query method predicate keywords and modifiers}

\begin{table}[ht]
\begin{tabular}{ | r | r |}
    \hline
    Logical keyword &	Keyword expressions \\
    \hline
    AND & And \\
    OR &  Or \\
    AFTER & After, IsAfter \\
    BEFORE & Before, IsBefore\\
    CONTAINING&Containing, IsContaining, Contains\\
    BETWEEN&Between, IsBetween\\
    ENDING\_WITH&EndingWith, IsEndingWith, EndsWith\\
    EXISTS&Exists\\
    FALSE&False, IsFalse\\
    GREATER\_THAN&GreaterThan, IsGreaterThan\\
    GREATER\_THAN\_EQUALS&GreaterThanEqual, IsGreaterThanEqual\\
    IN&In, IsIn\\
    IS&Is, Equals, (or no keyword)\\
    IS\_EMPTY&IsEmpty, Empty\\
    IS\_NOT\_EMPTY&IsNotEmpty, NotEmpty\\
    IS\_NOT\_NULL&NotNull, IsNotNull\\
    IS\_NULL&Null, IsNull\\
    LESS\_THAN&LessThan, IsLessThan\\
    LESS\_THAN\_EQUAL&LessThanEqual, IsLessThanEqual\\
    LIKE&Like, IsLike\\
    NEAR&Near, IsNear\\
    NOT&Not, IsNotNOT\_INNotIn, IsNotIn\\
    NOT\_LIKE&NotLike, IsNotLike\\
    REGEX&Regex, MatchesRegex, Matches\\
    STARTING\_WITH&StartingWith, IsStartingWith, StartsWith\\
    TRUE&True, IsTrue\\
    WITHIN&Within, IsWithin\\
    \hline
\end{tabular}
\end{table}

    In addition to filter predicates, the following list of modifiers is supported:
    \begin{itemize}
        \item IgnoreCase, IgnoringCase
        \item AllIgnoreCase, AllIgnoringCase
        \item OrderBy... (e. g. OrderByFirstnameAscLastnameDesc).
    \end{itemize}

\section{Programmatic Transaction Management}

Instead of using the @Transaction annotation, transactions can be managed programmatically using TransactionTemplate.

To be used, it needs to be initialized it with a PlatformTransactionManager.

Example:

\begin{lstlisting}
    class ManualTransactionIntegrationTest {

        @Autowired
        private PlatformTransactionManager transactionManager;

        private TransactionTemplate transactionTemplate;

        @BeforeEach
        void setUp() {
            transactionTemplate = new TransactionTemplate(transactionManager);
        }

        // omitted
    }
\end{lstlisting}

When using Spring Boot, an appropriate bean of type PlatformTransactionManager will be automatically registered, so we just need to inject it. Otherwise, we have to manually register a PlatformTransactionManager bean.

The correct order of operations when using TransactionTemplate in programmatic transaction management is:

\begin{itemize}
    \item begin transaction
    \item execute callback (which contains the transactional code)
    \item commit transaction if the callback executes successfully
    \item rollback transaction if an exception occurs during callback execution
\end{itemize}



\section{Spring Security}
\subsection{Overview}

Architecture Overview (see \ref{fig:spring-security}):

\begin{figure}[h]
    \centering
    \includegraphics[width=1\linewidth]{spring-security}
    \caption{Spring Security Architecture Overview}
    \label{fig:spring-security}
\end{figure}

\subsection{Filter Chain}

Overview (see \ref{fig:filter-chain}):

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{filter-chain}
    \caption{Spring Security Filter Chain}
    \label{fig:filter-chain}
\end{figure}

Example (see \ref{fig:filter-chain-example}):

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{filter-chain-example}
    \caption{Example Filter Chain}
    \label{fig:filter-chain-example}
\end{figure}

\subsection{Authentication}

Overview (see \ref{fig:authentication}):

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{authentication}
    \caption{Spring Security Filter Chain}
    \label{fig:authentication}
\end{figure}
\subsection{Authorization}

All Authentication implementations store a list of GrantedAuthority objects. These represent the authorities that have been granted to the principal. The GrantedAuthority objects are inserted into the Authentication object by the AuthenticationManager and are later read by AuthorizationManager instances when making authorization decisions.

The GrantedAuthority interface has only one method:

\begin{lstlisting}
    String getAuthority();
\end{lstlisting}

String getAuthority();

This method is used by an AuthorizationManager instance to obtain a precise String representation of the GrantedAuthority.

Spring Security includes one concrete GrantedAuthority implementation: SimpleGrantedAuthority. All AuthenticationProvider instances included with the security architecture use SimpleGrantedAuthority to populate the Authentication object.

By default, role-based authorization rules include ROLE\_ as a prefix. You can customize this with GrantedAuthorityDefaults.

You can configure the authorization rules to use a different prefix by exposing a GrantedAuthorityDefaults bean, like so:

\begin{lstlisting}
   @Bean
   static GrantedAuthorityDefaults grantedAuthorityDefaults() {
       return new GrantedAuthorityDefaults("MYPREFIX_");
   }
\end{lstlisting}

You expose GrantedAuthorityDefaults using a static method to ensure that Spring publishes it before it initializes Spring Security’s method security @Configuration classes.

\subsubsection{Invocation Handling}

Spring Security provides interceptors that control access to secure objects, such as method invocations or web requests. A pre-invocation decision on whether the invocation is allowed to proceed is made by AuthorizationManager instances. Also post-invocation decisions on whether a given value may be returned is made by AuthorizationManager instances.

AuthorizationManagers are called by Spring Security’s request-based, method-based, and message-based authorization components and are responsible for making final access control decisions.

The AuthorizationManager interface contains two methods:

\begin{lstlisting}
    AuthorizationDecision check(Supplier<Authentication> authentication, Object secureObject);

    default void verify(Supplier<Authentication> authentication, Object secureObject)
    throws AccessDeniedException {
        // ...
    }
\end{lstlisting}

The AuthorizationManager's check method is passed all the relevant information it needs in order to make an authorization decision. In particular, passing the secure Object enables those arguments contained in the actual secure object invocation to be inspected. For example, let’s assume the secure object was a MethodInvocation. It would be easy to query the MethodInvocation for any Customer argument, and then implement some sort of security logic in the AuthorizationManager to ensure the principal is permitted to operate on that customer. Implementations are expected to return a positive AuthorizationDecision if access is granted, negative AuthorizationDecision if access is denied, and a null AuthorizationDecision when abstaining from making a decision.

verify calls check and subsequently throws an AccessDeniedException in the case of a negative AuthorizationDecision.

Here is an overview of AuthorizationManager implementations: see \ref{fig:auth-manag-impl}.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{auth-manag-impl}
    \caption{Spring Security Filter Chain}
    \label{fig:auth-manag-impl}
\end{figure}

\subsubsection{Method Security}

Spring Security also supports modeling at the method level.

You can activate it in your application by annotating any @Configuration class with @EnableMethodSecurity or adding <method-security> to any XML configuration file. (Note: Spring Boot Starter Security does not activate method-level authorization by default.)

Then, you are immediately able to annotate any Spring-managed class or method with @PreAuthorize, @PostAuthorize, @PreFilter, and @PostFilter to authorize method invocations, including the input parameters and return values.

Spring Security’s method authorization support is handy for:

\begin{itemize}
    \item Extracting fine-grained authorization logic; for example, when the method parameters and return values contribute to the authorization decision.
    \item Enforcing security at the service layer.
    \item Stylistically favoring annotation-based over HttpSecurity-based configuration.
\end{itemize}

And since Method Security is built using Spring AOP, you have access to all its expressive power to override Spring Security’s defaults as needed.

Example:

\begin{lstlisting}
   @Service
   public class MyCustomerService {
       @PreAuthorize("hasAuthority('permission:read')")
       @PostAuthorize("returnObject.owner == authentication.name")
       public Customer readCustomer(String id) { ... }
   }
\end{lstlisting}

\section{Spring Testing: MockMvc}

The Spring MVC Test framework, also known as MockMvc, aims to provide more complete testing for Spring MVC controllers without a running server. It does that by invoking the DispatcherServlet and passing “mock” implementations of the Servlet API from the spring-test module which replicates the full Spring MVC request handling without a running server.

\subsection{Implications}

As opposed to @SpringBootTest, MockMvc is built on Servlet API mock implementations from the spring-test module and does not rely on a running container.

MockMvc starts out with a blank MockHttpServletRequest. Whatever is added to it is what the request becomes. There is no jsessionid cookie; no forwarding, error, or async dispatches; and no JSP rendering. Instead, “forwarded” and “redirected” URLs are saved in the MockHttpServletResponse and can be \textit{asserted with expectations}.

This means that, if you use JSPs, you can verify the JSP page to which the request was forwarded, but no HTML is rendered. In other words, the JSP is not invoked. Note, however, that all other rendering technologies that do not rely on forwarding, such as Thymeleaf and Freemarker, render HTML to the response body as expected. The same is true for rendering JSON, XML, and other formats through @ResponseBody methods.

\subsection{Static imports}

When using MockMvc directly to perform requests, the following static imports are needed:

\begin{itemize}
    \item MockMvcBuilders.*

    \item MockMvcRequestBuilders.*

    \item MockMvcResultMatchers.*

    \item MockMvcResultHandlers.*
\end{itemize}

\subsection{Setup}

MockMvc can be setup in one of two ways. One is to point directly to the controllers you want to test and programmatically configure Spring MVC infrastructure. Example:

\begin{lstlisting}
    class MyWebTests {

        MockMvc mockMvc;

        @BeforeEach
        void setup() {
            this.mockMvc = MockMvcBuilders.standaloneSetup(new AccountController()).build();
        }

        // ...

    }
\end{lstlisting}

The second is to point to Spring configuration with Spring MVC and controller infrastructure in it.

\begin{lstlisting}
    @SpringJUnitWebConfig(locations = "my-servlet-context.xml")
    class MyWebTests {

        MockMvc mockMvc;

        @BeforeEach
        void setup(WebApplicationContext wac) {
            this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
        }

        // ...

    }
\end{lstlisting}

\subsection{Queries with MockMvc}

Example queries using MockMvc:

\begin{lstlisting}
    mockMvc.perform(post("/hotels/{id}", 42).accept(MediaType.APPLICATION_JSON));

    // a file upload request that internally uses MockMultipartHttpServletRequest
    mockMvc.perform(multipart("/doc").file("a1", "ABC".getBytes("UTF-8")));

    // specifying query parameters in URI template style
    mockMvc.perform(get("/hotels?thing={thing}", "somewhere"));

    // adding Servlet request parameters that represent either query or form parameters
    mockMvc.perform(get("/hotels").param("thing", "somewhere"));


\end{lstlisting}


\section{Mocking in detail: @Mock vs. @MockBean}

@Mock is an annotation provided by the Mockito library. It is used to create mock objects for dependencies that are not part of the Spring context.

The @Mock annotation is typically used in conjunction with the MockitoJUnitRunner or MockitoExtension to initialize the mock objects.

Example:

\begin{lstlisting}
    import static org.mockito.Mockito.*;

    @RunWith(MockitoJUnitRunner.class)
    public class UserServiceTest {

        @Mock
        private UserRepository userRepository;

        // inject mock objects into UserService
        @InjectMocks
        private UserService userService;

        @Test
        public void testGetUserById() {
            // Given
            User mockedUser = new User("John", "Doe", 25);
            when(userRepository.findById(1L)).thenReturn(
            Optional.of(mockedUser));

            // When
            User result = userService.getUserById(1L);

            // Then
            assertNotNull(result);
            assertEquals("John", result.getFirstName());

            // Verify that the findById method was called
            verify(userRepository).findById(1L);
        }
    }
\end{lstlisting}

In contrast, @MockBean is a Spring Boot-specific annotation provided by the Spring Boot Test module. It is used to create mock objects for dependencies that are part of the Spring context.
Example:

\begin{lstlisting}
    @SpringBootTest
    public class UserServiceIntegrationTest {

        @Autowired
        private UserService userService;

        @MockBean
        private UserRepository userRepository;

        @Test
        public void testGetUserById() {
            // same as above
        }
    }
\end{lstlisting}


Key differences:

\begin{itemize}
    \item @Mock can only be applied to fields and parameters, whereas @MockBean can only be applied to classes and fields.
    \item @Mock can be used to mock any Java class or interface while @MockBean only allows for mocking of Spring beans or creation of mock Spring beans. It can be used to mock existing beans, but also to create new beans that will belong to the Spring application context.
    \item To be able to use the @MockBean annotation, the Spring runner (@RunWith(SpringRunner.class) ) is used, whereas @Mock is used with MockitoJUnitRunner.
    \item @MockBean can be used to create custom annotations for specific, reoccurring, needs.
\end{itemize}

Both @Mock and @MockBean are included in spring-boot-starter-test.

\section{Spring MVC}
\subsection{MVC Config}

The MVC Java configuration and the MVC XML namespace provide default configuration suitable for most applications and a configuration API to customize it.

You can use the @EnableWebMvc annotation to enable MVC configuration with programmatic configuration, or <mvc:annotation-driven> with XML configuration:

\begin{lstlisting}
    @Configuration
    @EnableWebMvc
    public class WebConfiguration {
    }
\end{lstlisting}

The preceding example registers a number of Spring MVC infrastructure beans and adapts to dependencies available on the classpath (for example, payload converters for JSON, XML, and others).

\subsection{MVC Config API}

In Java configuration, you can implement the WebMvcConfigurer interface:

\begin{lstlisting}@Configuration
    public class WebConfiguration implements WebMvcConfigurer {

        // Implement configuration methods...
    }
\end{lstlisting}

\subsection{Type Conversion}

By default, formatters for various number and date types are installed, along with support for customization via @NumberFormat, @DurationFormat, and @DateTimeFormat on fields and parameters.

To register custom formatters and converters, use the following:

\begin{lstlisting}
    @Configuration
    public class WebConfiguration implements WebMvcConfigurer {

        @Override
        public void addFormatters(FormatterRegistry registry) {
            // ...
        }
    }
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\subsection{Validation}

By default, if Bean Validation is present on the classpath (for example, Hibernate Validator), the LocalValidatorFactoryBean is registered as a global Validator for use with @Valid and @Validated on controller method arguments.

You can customize the global Validator instance, as the following example shows:

\begin{lstlisting}
    @Configuration
    public class WebConfiguration implements WebMvcConfigurer {

        @Override
        public Validator getValidator() {
            Validator validator = new OptionalValidatorFactoryBean();
            // ...
            return validator;
        }
    }
\end{lstlisting}

Note that you can also register Validator implementations locally, as the following example shows:

\begin{lstlisting}
    @Controller
    public class MyController {

        @InitBinder
        public void initBinder(WebDataBinder binder) {
            binder.addValidators(new FooValidator());
        }
    }

\end{lstlisting}

\subsection{Interceptors}

You can register interceptors to apply to incoming requests, as the following example shows:
@Configuration
public class WebConfiguration implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LocaleChangeInterceptor());
    }
}

\begin{lstlisting}
    @Configuration
    public class WebConfiguration implements WebMvcConfigurer {

        @Override
        public void addInterceptors(InterceptorRegistry registry) {
            registry.addInterceptor(new LocaleChangeInterceptor());
        }
    }
\end{lstlisting}

\subsection{Content Types}

You can configure how Spring MVC determines the requested media types from the request (for example, Accept header, URL path extension, query parameter, and others).

By default, only the Accept header is checked.

You can customize requested content type resolution, as the following example shows:

\begin{lstlisting}
    @Configuration
    public class WebConfiguration implements WebMvcConfigurer {

        @Override
        public void configureContentNegotiation(
        ContentNegotiationConfigurer configurer) {
            configurer.mediaType("json", MediaType.APPLICATION_JSON);
            configurer.mediaType("xml", MediaType.APPLICATION_XML);
        }
    }
\end{lstlisting}

\subsection{Message Converters}

You can set the HttpMessageConverter instances to use in Java configuration, replacing the ones used by default, by overriding configureMessageConverters(). You can also customize the list of configured message converters at the end by overriding extendMessageConverters().

In a Spring Boot application, the WebMvcAutoConfiguration adds any HttpMessageConverter beans it detects, in addition to default converters. Hence, in a Boot application, prefer to use the HttpMessageConverters mechanism.

Or alternatively, use extendMessageConverters to modify message converters at the end.

The following example adds XML and Jackson JSON converters with a customized ObjectMapper instead of the default ones:

\begin{lstlisting}
    @Configuration
    public class WebConfiguration implements WebMvcConfigurer {

        @Override
        public void configureMessageConverters(
        List<HttpMessageConverter<?>> converters) {
            Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder()
            .indentOutput(true)
            .dateFormat(new SimpleDateFormat("yyyy-MM-dd"))
            .modulesToInstall(new ParameterNamesModule());
            converters.add(new MappingJackson2HttpMessageConverter(
            builder.build()));
            converters.add(new MappingJackson2XmlHttpMessageConverter(
            builder.createXmlMapper(true).build()));
        }
    }
\end{lstlisting}

\subsection{HTTP Message Conversion}

The spring-web module contains the HttpMessageConverter interface for reading and writing the body of HTTP requests and responses through InputStream and OutputStream. HttpMessageConverter instances are used on the client side (for example, in the RestClient) and on the server side (for example, in Spring MVC REST controllers).

Concrete implementations for the main media (MIME) types are provided in the framework and are, by default, registered with the RestClient and RestTemplate on the client side and with RequestMappingHandlerAdapter on the server side (see Configuring Message Converters).

Some implementations of HttpMessageConverter are:

    \begin{lstlisting}
    StringHttpMessageConverter
    FormHttpMessageConverter
    ByteArrayHttpMessageConverter
    MarshallingHttpMessageConverter
    JsonbHttpMessageConverter
    ProtobufHttpMessageConverter
    ProtobufJsonFormatHttpMessageConverter
    \end{lstlisting}

\subsection{URI Links}

\subsubsection{UriComponents}

UriComponentsBuilder helps to build URI’s from URI templates with variables.

\begin{lstlisting}
    UriComponents uriComponents = UriComponentsBuilder
    .fromUriString("https://example.com/hotels/{hotel}")
    .queryParam("q", "{q}")
    .encode()
    .build();

    URI uri = uriComponents.expand("Westin", "123").toUri();

    Static factory method with a URI template.
    Add or replace URI components.
    Request to have the URI template and URI variables encoded.
    Build a UriComponents.
    Expand variables and obtain the URI.

\end{lstlisting}

The preceding example can be consolidated into one chain and shortened with buildAndExpand:

\begin{lstlisting}
    URI uri = UriComponentsBuilder
    .fromUriString("https://example.com/hotels/{hotel}")
    .queryParam("q", "{q}")
    .encode()
    .buildAndExpand("Westin", "123")
    .toUri();

\end{lstlisting}

You can shorten it further by going directly to a URI (which implies encoding):

\begin{lstlisting}
    URI uri = UriComponentsBuilder
    .fromUriString("https://example.com/hotels/{hotel}")
    .queryParam("q", "{q}")
    .build("Westin", "123");

\end{lstlisting}

You can shorten it further still with a full URI template:

\begin{lstlisting}
    URI uri = UriComponentsBuilder
    .fromUriString("https://example.com/hotels/{hotel}?q={q}")
    .build("Westin", "123");
\end{lstlisting}

\subsubsection{UriBuilder}

UriComponentsBuilder implements UriBuilder. You can create a UriBuilder, in turn, with a UriBuilderFactory. Together, UriBuilderFactory and UriBuilder provide a pluggable mechanism to build URIs from URI templates, based on shared configuration, such as a base URL, encoding preferences, and other details.

You can configure RestTemplate and WebClient with a UriBuilderFactory to customize the preparation of URIs. DefaultUriBuilderFactory is a default implementation of UriBuilderFactory that uses UriComponentsBuilder internally and exposes shared configuration options.

The following example shows how to configure a RestTemplate:
\begin{lstlisting}
    // import org.springframework.web.util.
        DefaultUriBuilderFactory.EncodingMode;

    String baseUrl = "https://example.org";
    DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);
    factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

    RestTemplate restTemplate = new RestTemplate();
    restTemplate.setUriTemplateHandler(factory);

    In addition, you can also use DefaultUriBuilderFactory directly. It is similar to using UriComponentsBuilder but, instead of static factory methods, it is an actual instance that holds configuration and preferences.

    String baseUrl = "https://example.com";
    DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory(baseUrl);

    URI uri = uriBuilderFactory.uriString("/hotels/{hotel}")
    .queryParam("q", "{q}")
    .build("Westin", "123");


\begin{lstlisting}
    management.endpoint.shutdown.enabled=true
\end{lstlisting}

\subsection{View Controllers}

This is a shortcut for defining a ParameterizableViewController that immediately forwards to a view when invoked. You can use it in static cases when there is no Java controller logic to run before the view generates the response.

The following example forwards a request for / to a view called home:

\begin{lstlisting}
    @Configuration
    public class WebConfiguration implements WebMvcConfigurer {

        @Override
        public void addViewControllers(ViewControllerRegistry registry) {
            registry
            .addViewController("/")
            .setViewName("home");
        }
    }
\end{lstlisting}

\subsection{View Resolvers}

The MVC configuration simplifies the registration of view resolvers.

The following example configures content negotiation view resolution by using JSP and Jackson as a default View for JSON rendering:

\begin{lstlisting}
    @Configuration
    public class WebConfiguration implements WebMvcConfigurer {

        @Override
        public void configureViewResolvers(ViewResolverRegistry registry) {
            registry.enableContentNegotiation(new MappingJackson2JsonView());
            registry.jsp();
        }
    }
\end{lstlisting}




\section{Spring Boot (Web): Servlet Web Applications}

If you want to build servlet-based web applications, you can take advantage of Spring Boot’s auto-configuration for Spring MVC or Jersey.

The \textit{Spring Web MVC framework} (often referred to as “Spring MVC”) is a rich “model view controller” web framework. Spring MVC lets you create special @Controller or @RestController beans to handle incoming HTTP requests. Methods in your controller are mapped to HTTP by using @RequestMapping annotations.

Architecture Overview (see \ref{fig:spring-web}):

\begin{figure}[h]
    \centering
    \includegraphics[width=1\linewidth]{spring-web}
    \caption{Spring Boot Web Architecture Overview}
    \label{fig:spring-web}
\end{figure}

\subsection{Externalized Configuration}

Spring Boot lets you externalize your configuration so that you can work with the same application code in different environments. You can use a variety of external configuration sources including Java properties files, YAML files, environment variables, and command-line arguments.

Property values can be injected directly into your beans by using the \lstinline |@Value| annotation, accessed through Spring’s Environment abstraction, or be bound to structured objects through \lstinline[]|@ConfigurationProperties|.

Differences between both are:

\begin{itemize}
    \item @ConfigurationProperties does support relaxed binding, allowing for more flexibility in property names and values. On the other hand, @Value does not have this feature, requiring an exact match between the property name and the field.
    \item @ConfigurationProperties can be validated using JSR-303 bean validation, providing a way to enforce constraints on the properties being bound. In contrast, @Value does not have built-in support for bean validation.
    \item @ConfigurationProperties is designed to bind properties to entire classes, allowing for a more structured and organized approach to configuration. On the other hand, @Value is typically used to bind specific properties to individual fields within a class.
\end{itemize}

Spring Boot uses a very particular PropertySource order that is designed to allow sensible overriding of values. Sources are considered in the following order:

\begin{itemize}
    \item Default properties (specified by setting SpringApplication.setDefaultProperties).
    \item @PropertySource annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins.
    \item Config data (such as application.properties files).
    \item A RandomValuePropertySource that has properties only in random.*.
    \item OS environment variables.
    \item Java System properties (System.getProperties()).
    \item JNDI attributes from java:comp/env.
    \item ServletContext init parameters.
    \item ServletConfig init parameters.
    \item Properties from SPRING\_APPLICATION\_JSON (inline JSON embedded in an environment variable or system property).
    \item Command line arguments.
    \item properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application.
    \item @DynamicPropertySource annotations in your tests.
    \item @TestPropertySource annotations on your tests.
    \item Devtools global settings properties in the \$HOME/.config/spring-boot directory when devtools is active.
\end{itemize}

\subsection{ApplicationContext in Boot}

A SpringApplication attempts to create the right type of ApplicationContext on your behalf. The algorithm used to determine a WebApplicationType is the following:

\begin{itemize}
    \item If Spring MVC is present, an AnnotationConfigServletWebServerApplicationContext is used.
    \item If Spring MVC is not present and Spring WebFlux is present, an AnnotationConfigReactiveWebServerApplicationContext is used.
    \item Otherwise, AnnotationConfigApplicationContext is used.
\end{itemize}

It is also possible to take complete control of the ApplicationContext type that is used by calling setApplicationContextFactory(...).


Architecture Overview (see \ref{fig:spring-web}):

\begin{figure}[h]
    \centering
    \includegraphics[width=1\linewidth]{spring-web}
    \caption{Spring Boot Web Architecture Overview}
    \label{fig:spring-web}
\end{figure}

\subsection{Spring Boot Auto-Configuration}

When @EnableAutoConfiguration is present, beans annotated with @AutoConfiguration  will be configured.

In spring-boot-autoconfigure.jar, /META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports lists the classes by default autoconfigured by Spring.

Spring's DataSourceAutoConfiguration class is one example. See fig. \ref{fig:datasourceautoconfiguration}.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{datasourceautoconfiguration}
    \caption{Spring's DataSourceAutoConfiguration class.}
    \label{fig:datasourceautoconfiguration}
\end{figure}


\subsection{Externalized Configuration}

Spring Boot lets you externalize your configuration so that you can work with the same application code in different environments. You can use a variety of external configuration sources including Java properties files, YAML files, environment variables, and command-line arguments.

Property values can be injected directly into your beans by using the \lstinline |@Value| annotation, accessed through Spring’s Environment abstraction, or be bound to structured objects through \lstinline[]|@ConfigurationProperties|.

Differences between both are:

\begin{itemize}
    \item @ConfigurationProperties does support relaxed binding, allowing for more flexibility in property names and values. On the other hand, @Value does not have this feature, requiring an exact match between the property name and the field.
    \item @ConfigurationProperties can be validated using JSR-303 bean validation, providing a way to enforce constraints on the properties being bound. In contrast, @Value does not have built-in support for bean validation.
    \item @ConfigurationProperties is designed to bind properties to entire classes, allowing for a more structured and organized approach to configuration. On the other hand, @Value is typically used to bind specific properties to individual fields within a class.
\end{itemize}

Spring Boot uses a very particular PropertySource order that is designed to allow sensible overriding of values. Sources are considered in the following order:

\begin{itemize}
    \item Default properties (specified by setting SpringApplication.setDefaultProperties).
    \item @PropertySource annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins.
    \item Config data (such as application.properties files).
    \item A RandomValuePropertySource that has properties only in random.*.
    \item OS environment variables.
    \item Java System properties (System.getProperties()).
    \item JNDI attributes from java:comp/env.
    \item ServletContext init parameters.
    \item ServletConfig init parameters.
    \item Properties from SPRING\_APPLICATION\_JSON (inline JSON embedded in an environment variable or system property).
    \item Command line arguments.
    \item properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application.
    \item @DynamicPropertySource annotations in your tests.
    \item @TestPropertySource annotations on your tests.
    \item Devtools global settings properties in the \$HOME/.config/spring-boot directory when devtools is active.
\end{itemize}

\subsection{ApplicationContext in Boot}

A SpringApplication attempts to create the right type of ApplicationContext on your behalf. The algorithm used to determine a WebApplicationType is the following:

\begin{itemize}
    \item If Spring MVC is present, an AnnotationConfigServletWebServerApplicationContext is used.
    \item If Spring MVC is not present and Spring WebFlux is present, an AnnotationConfigReactiveWebServerApplicationContext is used.
    \item Otherwise, AnnotationConfigApplicationContext is used.
\end{itemize}

It is also possible to take complete control of the ApplicationContext type that is used by calling setApplicationContextFactory(...).


\begin{lstlisting}
    management.endpoint.shutdown.enabled=true
\end{lstlisting}
\begin{lstlisting}
    management.endpoint.shutdown.enabled=true
\end{lstlisting}
\begin{lstlisting}
    management.endpoint.shutdown.enabled=true
\end{lstlisting}

\subsection{Testing with Spring Boot}

Test support is provided by two modules: spring-boot-test contains core items, and spring-boot-test-autoconfigure supports auto-configuration for tests.

spring-boot-starter-test imports both Spring Boot test modules as well as JUnit Jupiter, AssertJ, Hamcrest, and a number of other useful libraries. Precisely:



\begin{itemize}
    \item JUnit 5: The de-facto standard for unit testing Java applications.

    \item Spring Test and Spring Boot Test: Utilities and integration test support for Spring Boot applications.

    \item AssertJ: A fluent assertion library.

    \item Hamcrest: A library of matcher objects (also known as constraints or predicates).

    \item Mockito: A Java mocking framework.

    \item JSONassert: An assertion library for JSON.

    \item JsonPath: XPath for JSON.

    \item Awaitility: A library for testing asynchronous systems.

\end{itemize}



By default, @SpringBootTest will not start a server. You can use the webEnvironment attribute of @SpringBootTest to further refine how your tests run:

\begin{itemize}
    \item MOCK(Default) : Loads a web ApplicationContext and provides a mock web environment. Embedded servers are not started when using this annotation. If a web environment is not available on your classpath, this mode transparently falls back to creating a regular non-web ApplicationContext. It can be used in conjunction with @AutoConfigureMockMvc or @AutoConfigureWebTestClient for mock-based testing of your web application.

    \item RANDOM\_PORT: Loads a WebServerApplicationContext and provides a real web environment. Embedded servers are started and listen on a random port.

    \item DEFINED\_PORT: Loads a WebServerApplicationContext and provides a real web environment. Embedded servers are started and listen on a defined port (from your application.properties) or on the default port of 8080.

    \item NONE: Loads an ApplicationContext by using SpringApplication but does not provide any web environment (mock or otherwise).
\end{itemize}

\subsection{Test Configuration}

In Spring testing in general, we use @ContextConfiguration(classes=...) in order to specify which Spring @Configuration to load.
When testing Spring Boot applications, this is often not required. Spring Boot’s @*Test annotations search for the primary configuration automatically.

The search algorithm works up from the package that contains the test until it finds a class annotated with @SpringBootApplication or @SpringBootConfiguration.

To customize the primary configuration, one can use a nested @TestConfiguration class. Unlike a nested @Configuration class, which would be used instead of the application’s primary configuration, a nested @TestConfiguration class is used in addition to the primary configuration.

\subsection{Testing With a Mock Environment}

By default, @SpringBootTest does not start the server but instead sets up a mock environment for testing web endpoints.

With Spring MVC, we can query our web endpoints using MockMvc or WebTestClient, as shown in the following example:

\begin{lstlisting}
    @SpringBootTest
    @AutoConfigureMockMvc
    class MyMockMvcTests {

        @Test
        void testWithMockMvc(@Autowired MockMvc mvc) throws Exception {
            mvc.perform(get("/")).andExpect(status().isOk()).andExpect(content().string("Hello World"));
        }

        // If Spring WebFlux is on the classpath, you can drive MVC tests with a WebTestClient
        @Test
        void testWithWebTestClient(@Autowired WebTestClient webClient) {
            webClient
            .get().uri("/")
            .exchange()
            .expectStatus().isOk()
            .expectBody(String.class).isEqualTo("Hello World");
        }

    }

\end{lstlisting}

\subsection{Auto-configured Spring MVC Tests}

To test whether Spring MVC controllers are working as expected, use the @WebMvcTest annotation.

@WebMvcTest auto-configures the Spring MVC infrastructure and limits scanned beans to @Controller, @ControllerAdvice, @JsonComponent, Converter, GenericConverter, Filter, HandlerInterceptor, WebMvcConfigurer, WebMvcRegistrations, and HandlerMethodArgumentResolver.

Regular @Component and @ConfigurationProperties beans are not scanned when the @WebMvcTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans.

Often, @WebMvcTest is limited to a single controller and is used in combination with @MockBean to provide mock implementations for required collaborators.

@WebMvcTest also auto-configures MockMvc.


\section{Spring Boot Actuator}

The recommended way to enable the features is to add a dependency on the spring-boot-starter-actuator starter.

\subsection{Endpoints}

Actuator endpoints let you monitor and interact with your application. Spring Boot includes a number of built-in endpoints and lets you add your own. For example, the health endpoint provides basic application health information.

You can enable or disable each individual endpoint and expose them (make them remotely accessible) over HTTP or JMX. An endpoint is considered to be available when it is \textit{both enabled and exposed}.

The built-in endpoints are auto-configured only when they are available. Most applications choose exposure over HTTP, where the ID of the endpoint and a prefix of /actuator is mapped to a URL. For example, by default, the health endpoint is mapped to /actuator/health.

By default, \textit{all endpoints except for shutdown are enabled}. To configure the enablement of an endpoint, use its management.endpoint.<id>.enabled property. The following example enables the shutdown endpoint:

\begin{lstlisting}
   management.endpoint.shutdown.enabled=true
\end{lstlisting}

If you prefer endpoint enablement to be opt-in rather than opt-out, set the management.endpoints.enabled-by-default property to false and use individual endpoint enabled properties to opt back in. The following example enables the info endpoint and disables all other endpoints:

\begin{lstlisting}
    management.endpoints.enabled-by-default=false
    management.endpoint.info.enabled=true
\end{lstlisting}

Disabled endpoints are removed entirely from the application context. If you want to change only the technologies over which an endpoint is exposed, use the include and exclude properties instead.

By default, only the health endpoint is \textit{exposed} over HTTP and JMX.

To change which endpoints are exposed, use the following technology-specific include and exclude properties: management.endpoints.jmx.exposure.exclude,
management.endpoints.jmx.exposure.include; management.endpoints.web.exposure.exclude, management.endpoints.web.exposure.include.

The include property lists the IDs of the endpoints that are exposed. The exclude property lists the IDs of the endpoints that should not be exposed. The exclude property takes precedence over the include property. You can configure both the include and the exclude properties with a list of endpoint IDs.

For example, to only expose the health and info endpoints over JMX, use the following property:

\begin{lstlisting}
    management.endpoints.jmx.exposure.include=health,info
\end{lstlisting}

* can be used to select all endpoints. For example, to expose everything over HTTP except the env and beans endpoints, use the following properties:

\begin{lstlisting}
    management.endpoints.web.exposure.include=*
    management.endpoints.web.exposure.exclude=env,beans

\end{lstlisting}

\subsubsection{Health information}

Information exposed by the health endpoint depends on the \lstinline|management.endpoint.health.show-details| and \lstinline|management.endpoint.health.show-components| properties, which can be configured with one of the following values: never, when-authorized, always
.

The default value is never. A user is considered to be authorized when they are in one or more of the endpoint’s roles. If the endpoint has no configured roles (the default), all authenticated users are considered to be authorized. You can configure the roles by using the management.endpoint.health.roles property.

Health information is collected from the content of a HealthContributorRegistry (by default, all HealthContributor instances defined in your ApplicationContext). Spring Boot includes a number of auto-configured HealthContributors, and you can also write your own.

A \lstinline|HealthContributor| can be either a \lstinline|HealthIndicator| or a \lstinline|CompositeHealthContributor|.

By default, the final system health is derived by a StatusAggregator, which sorts the statuses from each HealthIndicator based on an ordered list of statuses. The first status in the sorted list is used as the overall health status. If no HealthIndicator returns a status that is known to the StatusAggregator, an UNKNOWN status is used.

\paragraph{Auto-configured HealthIndicators}

\begin{lstlisting}
    cassandra
    couchbase
    db
    diskspace
    elasticsearch
    hazelcast
    influxdb
    jms
    ldap
    mail
    mongo
    neo4j
    ping
    rabbit
    redis
\end{lstlisting}

\paragraph{Writing Custom HealthIndicators}

To provide custom health information, you can register Spring beans that implement the HealthIndicator interface. You need to provide an implementation of the \lstinline|health()| method and return a \lstinline|Health| response. The Health response should include a status and can optionally include additional details to be displayed. The following code shows a sample HealthIndicator implementation:

    \begin{lstlisting}
    import org.springframework.boot.actuate.health.Health;
    import org.springframework.boot.actuate.health.HealthIndicator;
    import org.springframework.stereotype.Component;

    @Component
    public class MyHealthIndicator implements HealthIndicator {

        @Override
        public Health health() {
            int errorCode = check();
            if (errorCode != 0) {
                return Health.down().withDetail("Error Code", errorCode).build();
            }
            return Health.up().build();
        }

        private int check() {
            // perform some specific health check
            return ...
        }

    }
    \end{lstlisting}

The identifier for a given HealthIndicator is the name of the bean without the HealthIndicator suffix, if it exists. In the preceding example, the health information is available in an entry named my.

\subsubsection{Info Endpoint}
\paragraph{Application Information}

Application information exposes various information collected from all \lstinline|InfoContributor| beans defined in your ApplicationContext. Spring Boot includes a number of auto-configured InfoContributor beans, and you can write your own.

Auto-configured InfoContributors may be:

\begin{lstlisting}
    // if there's a META-INF/build-info.properties resource
    build
    //  Exposes any property from the Environment whose name starts with info
    env
    // git.properties resource exists
    git
    java
    os
    process
\end{lstlisting}

Whether an individual contributor is enabled is controlled by its management.info.someid.enabled property.
Different contributors have different defaults for this property, depending on their prerequisites and the nature of the information that they expose.

With no prerequisites to indicate that they should be enabled, the env, java, os, and process contributors are disabled by default.

The build and git info contributors are enabled by default.

\paragraph{Custom Application Information}

When the env contributor is enabled, you can customize the data exposed by the info endpoint by setting info.* Spring properties. \textit{All Environment properties under the info key are automatically exposed.} For example, you could add the following settings to your application.properties file:

    \begin{lstlisting}
    info.app.encoding=UTF-8
    info.app.java.source=17
    info.app.java.target=17

    \end{lstlisting}

\paragraph{Writing Custom InfoContributors}

    To provide custom application information, you can register Spring beans that implement the InfoContributor interface.

\begin{lstlisting}
    import java.util.Collections;

    import org.springframework.boot.actuate.info.Info;
    import org.springframework.boot.actuate.info.InfoContributor;
    import org.springframework.stereotype.Component;

    @Component
    public class MyInfoContributor implements InfoContributor {

        @Override
        public void contribute(Info.Builder builder) {
            builder.withDetail("example", Collections.singletonMap("key", "value"));
        }

    }
\end{lstlisting}



\subsection{Monitoring and Management Over HTTP}

\subsubsection{Configuration}

\begin{lstlisting}
    // base for all endpoints
    management.endpoints.web.base-path=

    // for a specific endpoint
    management.endpoints.web.path-mapping.<actuator>
    // e.g.
    management.endpoints.web.path-mapping.health=custom-health

    // prt
    management.server.port=8081
\end{lstlisting}

\begin{lstlisting}
    management.endpoint.shutdown.enabled=true
\end{lstlisting}
\begin{lstlisting}
    management.endpoint.shutdown.enabled=true
\end{lstlisting}
\begin{lstlisting}
    management.endpoint.shutdown.enabled=true
\end{lstlisting}



\end{document}




























