\documentclass{scrartcl}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amssymb}
\usepackage[colorlinks=true, urlcolor=blue, linkcolor=red]{hyperref}
\usepackage{graphicx}

\definecolor{lightcyan}{HTML}{E0FFFF}




\begin{document}
    \lstset{
        language=Java,
        %numbers=left,
        stepnumber=1,
        numbersep=5pt,
        backgroundcolor=\color{lightcyan},
        showspaces=false,
        showstringspaces=false,
        showtabs=false,
        tabsize=2,
        captionpos=b,
        breaklines=true,
        breakatwhitespace=true,
        title=\lstname,
        basicstyle=\small
    }

\section{Data Types}

\subsection{Date and Time}

\subsubsection{\lstinline$ LocalDate $}

    LocalDate is an immutable date-time object that represents a date, often viewed as year-month-day. Other date fields, such as day-of-year, day-of-week and week-of-year, can also be accessed.

    \begin{lstlisting}
        // to obtain, e.g.
        static LocalDate of(int year, int month, int dayOfMonth)
        static LocalDate of(int year, Month month, int dayOfMonth)
        static LocalDate ofInstant(Instant instant, ZoneId zone)
        static LocalDate parse(CharSequence text, DateTimeFormatter formatter)

        // instance methods, e.g.
        LocalDateTime atTime(int hour, int minute, int second, int nanoOfSecond)
        LocalDateTime atTime(LocalTime time)

        int getDayOfMonth()
        DayOfWeek getDayOfWeek()
        int getDayOfYear()
        Month getMonth()
        int getMonthValue()
        int getYear()

        // same for plus
        LocalDate minus(long amountToSubtract, TemporalUnit unit)
        LocalDate minusDays(long daysToSubtract)
        LocalDate minusMonths(long monthsToSubtract) //etc
    \end{lstlisting}

    Beware immutability:
    \begin{lstlisting}
        var date = LocalDate.of(2022, Month.APRIL, 30);
        date.plusDays(2); // does not change date
    \end{lstlisting}

\subsubsection{\lstinline$ LocalTime $}

    LocalTime is an immutable date-time object that represents a time, often viewed as hour-minute-second. Time is represented to nanosecond precision. For example, the value "13:45.30.123456789" can be stored in a LocalTime.

    \begin{lstlisting}
        // to obtain, e.g.
        static LocalTime of(int hour, int minute, int second, int nanoOfSecond)
        static LocalTime ofInstant(Instant instant, ZoneId zone)

        // instance methods, e.g.
        LocalDateTime atDate(LocalDate date)

        int getHour()
        int getMinute() //etc.

        // same for minus
        LocalTime plus(long amountToAdd, TemporalUnit unit)
        LocalTime plusNanos(long nanosToAdd) // etc.

        // returns copy
        LocalTime withHour(int hour)
        LocalTime withMinute(int minute) //etc.
        \end{lstlisting}

\subsubsection{\lstinline$ LocalDateTime $}

    \begin{lstlisting}
        // to obtain, e.g.
        static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)
        static LocalDateTime of(LocalDate date, LocalTime time)
        // instance methods analogous to above
    \end{lstlisting}

\subsubsection{\lstinline$ Month $}

    In addition to the textual enum name, each month-of-year has an int value (1-12).
    Do not use ordinal() to obtain the numeric representation of Month. Use getValue() instead.

    \begin{lstlisting}
        // to obtain, e.g.
        static Month of(int month)
        Month e = Month.of(10); // DECEMBER
        static Month valueOf(String name)
        Month m = Month.valueOf("DECEMBER"); // DECEMBER

        // instance methods, e.g.
        int getValue()
        int length(boolean leapYear)
        minus(long months)
        plus(long months)
    \end{lstlisting}

\subsubsection{\lstinline$ ChronoUnit $}

    \begin{lstlisting}
        // to obtain, e.g.
        static ChronoUnit valueOf(String name)

        // instance methods, e.g.
        <R extends Temporal> R addTo(R temporal, long amount) // returns a copy!
        long between(Temporal temporal1Inclusive, Temporal temporal2Exclusive)
\end{lstlisting}

\subsubsection{\lstinline$ Instant $}

     An \lstinline$ Instant $ represents a specific moment in time using GMT.
    Consequently, there is no time zone information.

    \begin{lstlisting}
        // to obtain, e.g.
        static Instant from(TemporalAccessor temporal)
        static Instant now()
        static Instant ofEpochMilli(long epochMilli)

        // instance methods, e.g.
        OffsetDateTime atOffset(ZoneOffset offset)
        ZonedDateTime atZone(ZoneId zone)

        Instant minus(long amountToSubtract, TemporalUnit unit) //returns copy! others too
        Instant minus(TemporalAmount amountToSubtract)

        Instant minusMillis(long millisToSubtract)
        Instant minusNanos(long nanosToSubtract)

        var instant = trainDay.toInstant(); // will not compile if this is a LocalDateTime!

    \end{lstlisting}

\subsubsection{\lstinline$ Period $}

    This class models a quantity or amount of time in terms of years, months and days. See Duration for the time-based equivalent to this class.

    Durations and periods differ in their treatment of daylight savings time when added to ZonedDateTime. A Duration will add an exact number of seconds, thus a duration of one day is always exactly 24 hours. By contrast, a Period will add a conceptual day, trying to maintain the local time.

    For example, consider adding a period of one day and a duration of one day to 18:00 on the evening before a daylight savings gap. The Period will add the conceptual day and result in a ZonedDateTime at 18:00 the following day. By contrast, the Duration will add exactly 24 hours, resulting in a ZonedDateTime at 19:00 the following day (assuming a one hour DST gap).

    The supported units of a period are YEARS, MONTHS and DAYS. All three fields are always present, but may be set to zero.

    The period is modeled as a directed amount of time, meaning that individual parts of the period may be negative.

    \begin{lstlisting}
        // to obtain, e.g.
        static Period between(LocalDate startDateInclusive, LocalDate endDateExclusive)
        static Period of(int years, int months, int days)
        static Period ofDays(int days) // other fields will be 0
        static Period ofMonths(int months)

        // instance methods, e.g.
        Temporal addTo(Temporal temporal)
        Period minusDays(long daysToSubtract) // all return copies!
        minusMonths(long monthsToSubtract)

        Period withMonths(int months) // copies, too!
        Period withYears(int years)

        int getDays()
        \end{lstlisting}

 \subsubsection{\lstinline$ Duration $}

    This class models a quantity or amount of time in terms of seconds and nanoseconds. It can be accessed using other duration-based units, such as minutes and hours. In addition, the DAYS unit can be used and is treated as exactly equal to 24 hours, thus ignoring daylight savings effects.

    See Period for the date-based equivalent to this class.

     \begin{lstlisting}
     // to obtain, e.g.
     static Duration of(long amount, TemporalUnit unit)
     static Duration ofDays(long days)

     // instance methods, e.g.
     Duration dividedBy(long divisor) // all these copy
     long dividedBy(Duration divisor)

     long get(TemporalUnit unit)
     int getNano()
     long getSeconds()
     \end{lstlisting}

 \subsection{String and StringBuilder}
 \subsubsection{\lstinline$ String $}

    \begin{lstlisting}
     // strip()-related methods (these are the only ones)
     strip(), stripLeading(), stripTrailing(), stripIndent()

     // indent():
     // indent(n) splits into lines and then indents each; also adds newline if missing at end.
     // indent(0) does not change the indentation, but still adds a normalizing line break
     System.out.println(phrase.indent(0).length());

     // translateEscapes()
     // these print 2 lines:
     System.out.println("cheetah\ncub");
     System.out.println("cheetah\ncub".translateEscapes());
     System.out.println("cheetah\\ncub".translateEscapes());
     - this prints 1:
     System.out.println("cheetah\\ncub");

     // format string
     var quotes = """
     \"The Quotes that Could\" // could remove both backslashes
     \"\"\"                    // could remove 2 backslashes
     """;

     // there is no reverse()
     \end{lstlisting}

 \subsubsection{\lstinline$ StringBuilder $}

    \begin{lstlisting}

        // instance methods, e.g.
        char charAt(int index)
        IntStream chars()

        int indexOf(String str)

        int length()

        StringBuilder
        delete(int start, int end)
    \end{lstlisting}

\subsection{Numbers}
\subsubsection{Number types: automatic promotion}

    Integer literals are considered int by default (size notwithstanding). But they can be automatically promoted to long or double.

    \begin{lstlisting}
        final ___ song = 6; // can be int, long, double (automatic promotion from int)
    \end{lstlisting}

\subsubsection{Autoboxing}

    Beware: cannot autobox and promote at the same time!

    \begin{lstlisting}

    \end{lstlisting}


\subsubsection{\lstinline$ Math $ methods}
    \begin{lstlisting}
        Math.round() // double -> double
        Math.max() // overloaded, returns passed-in type
        Math.pow() // double -> double
    \end{lstlisting}

\subsubsection{Parsing Strings}
    \begin{lstlisting}
        var numPigeons = Long.parseLong("100"); // returns long
        var numPigeons2 = Long.valueOf("100"); // returns Long
    \end{lstlisting}

    Examples:
    \begin{lstlisting}
        Boolean.valueOf("8").booleanValue() // false
        Character.valueOf('x').byteValue(); // does not compile
        Double.valueOf("9_.3").byteValue(); // NumberFormatException
        Long.valueOf(128).byteValue(); // - 128
    \end{lstlisting}

\subsection{Arrays}

    These are all legal array declarations:

    \begin{lstlisting}
        // no var allowed
        String[][] gamma;
        String[] delta[];
        String epsilon[][];
    \end{lstlisting}

\section{Operators}
\subsection{Kinds}
\subsubsection{Logical Operators}
    \begin{lstlisting}
        &&
        ||
        // no ~!
    \end{lstlisting}

\subsubsection{Bitwise Operators: Logical}
    \begin{lstlisting}
        &
        int result = 5 & 6; // 4    101 & 110 = 100
        |
        int result = 5 | 6; // 7    101 | 110 = 111
        ^
        int result = 5 ^ 6; // 3    101 ^ 110 = 011
        ~
        int result = ~6; // -7      0000 0110 -> 1111 1001 -> 0000 0110 + 1 -> 0000 0111
    \end{lstlisting}

    The bitwise NOT or complement operator is equivalent to negation of each bit in the input value. This will result in a negative number one smaller, i.e., obtain -x-1 from x.

    Steps: First we need to find its 2’s complement, and then convert the resultant binary number into a decimal number.

    \begin{enumerate}
        \item write 6 in binary: 0000 0110
        \item take complement: 1111 1001 // this is the 1's complement
        \item to get the 2's complement (since numbers are stored as 2’s complement), add 1: 1111
    \end{enumerate}

    To find the binary representation of -17, take the 2's complement of 17:
    \begin{enumerate}
        \item 17 = 0001 0001
        \item Take the bitwise complement: 1110 1110
        \item Add 1: 1110 1110 + 1 = 1110 1111
    \end{enumerate}

    To take the 2's complement of negative number:
    \begin{enumerate}
        \item Start from binary -17: 1110 1111
        \item     Take the the bitwise complement: 0001 0000
        \item     Add 1: 0001 0001
        \item     This gets back the 17!
    \end{enumerate}

    To find the decimal representation of a number given in binary, reverse steps
   \begin{enumerate}
       \item  Subtract 1: 1110 1111 - 1 = 1110 1110
       \item     Take the complement of the complement: 0001 0001
       \item     Change from base 2 back to base 10 16 + 1 = 17
       \item     Rewrite this as a negative integer: -17
   \end{enumerate}

\subsubsection{Bitwise operators: arithmetic}
    \begin{lstlisting}

        << // shift left (signed)
        >> shift right (signed)
        >> shift right (unsigned)

        12 << 2: 48 // *2^n
        12 >> 2: 3 // 1100 -> 0011 (pos.: fill with 0)
        -12 >> 2: -3 //               (neg..: fill with 1)
        12 >>> 2: 3 // 1100 -> 0011
        -12 >>> 2: 1073741821 // fill with 0 too
    \end{lstlisting}

\subsection{Precedence}

    Default evaluation order is left-to-right.

    \begin{tabular}{|l|c|r|}
        \hline
        Post-­unary operator& x++, x-- &  \\
        \hline
        Pre-­unary operator& ++x, ++x &  \\
        \hline
        Other unary operators& -­, !, ~, + &  Right-­to-­left \\
        \hline
        Cast(type)reference&  &  Right-­to-­left \\
        \hline
        Multiplication/division/modulus& *, /, \% &  \\
        \hline
        Addition/subtraction& +, - &  \\
        \hline
        Shift operators& $\ll, \gg, \ggg$ &  \\
        \hline
        Relational operators & $<$, $>$, $<=$, $>=$, instanceof & \\
        \hline
        Equal to/not equal to& ==, != &\\
        \hline
        Logical and& \& &  \\
        \hline
        Logical exclusive OR& \textasciicircum \\
        \hline
        Logical inclusive OR& $|$ &  \\
        \hline
        Conditional OR& $||$ &  \\
        \hline
        Ternary operator& e1 ? e2 : e3 & Right-­to-­left\\
        \hline
        Assignment operators& =, +=, -­=, *=, /=, \%=, \&=, \textasciicircum, & Right-­to-­left\\
        & $|$, $<<=$ , $>>=$, $>>>=$ & \\
        \hline
        Ternary operator& e1 ? e2 : e3 & Right-­to-­left\\
        \hline
        Arrow operator& $->$ &  \\\\
        \hline
    \end{tabular}
     \\

    In a nutshell:

    \begin{itemize}
        \item shift ops after +, -
        \item relational before equality before logical
        \item \& $|$ before \&\& $||$
        \item ternary thereafter but before assignment
        \item assignment last
    \end{itemize}

\section{Syntax}
\subsection{Allowed variable names}

    Names may contain: underscore, currency symbol, numbers, letters (first may not be a number)

\subsection{Variable declarations and initialization topics}

    For instance variables, on a single line only one type should be specified.



\subsection{Text blocks}

    Imagine a vertical line drawn on the leftmost non-­whitespace character in the text block. Everything to the left of it is incidental whitespace, and everything to the right is essential whitespace.

    Note:
    \begin{itemize}
        \item \ at end of line -> no newline!
        \item Space at end of line is ignored
        \item \textbackslash s yields two spaces
        \item  \textbackslash n yields additional line break
    \end{itemize}

    Example:

    \begin{lstlisting}
        String block = """              // on sep. line
        doe \
        doof""";                        // on same line
    \end{lstlisting}

\subsection{var}

    A var cannot be initialized with a null value without giving a type.

    var cannot be used in a multiple-­variable assignment.

\subsection{underscore}

    An underscore can be placed in any numeric literal, as long as it is not at the beginning, at the end, or next to a decimal point. Underscores can even be placed next to each other.

\subsection{switch}

\subsubsection{General}

        \begin{itemize}
            \item Supports: enum, byte, Byte, short, Short, char, Character, int, Integer,
            String, var (if resolves to one of those types)
            \item Does not support: boolean, Boolean, double, Double, float, Float
         \end{itemize}

\subsubsection{Statement}

    \begin{itemize}
        \item The value of a case statement must be a constant, a literal value, or a final variable (not, e.g., \lstinline$ case red:  $)
        \item May use comma to separate case constants in statements: e.g.,
            \begin{lstlisting}
                public int getAverageTemperate(Season s) {
                    switch (s) {
                        default:
                        case WINTER, SUMMER: return 30;
                }}
            \end{lstlisting}
    \end{itemize}

\subsubsection{Expression}

    \begin{itemize}
        \item A switch expression requires all possible case values to be handled, or a default to be added.
        \item switch expressions execute exactly one branch and do not use break statements.
        \item switch expressions need a semicolon.
        \item Can omit default clause in when either all the values of an enum are covered or no value is returned.
        \item Case labels must be compile-time constants.
        \item Every path must return a value.
    \end{itemize}

    Example:

    \begin{lstlisting}
        case 10 -> {"Jane";} // yield implied
        case 20 -> {yield "Lisa";}
        case 30 -> "Kelly";
        default -> "Unassigned";
    \end{lstlisting}

\subsection{ for (x : y)}

     A for-­each loop accepts arrays and classes that implement java.lang.Iterable, such as List. Not: String, StringBuilder

\subsection{Flow Scoping}

    Example:

    \begin{lstlisting}
        static void printIfString(Object o) {
            if (!(o instanceof String s)) {
                // 's' is NOT in scope
                return;
            } else {
                // 's' is in scope
                // s is a string
                System.out.println(s);
            }
        }

        // this is valid:
        if (x instanceof Foo(var v) && v != null) {
            A;
        }

        //this is NOT:
        if (x instanceof Foo(var v) || v != null) {
            A;
        }
    \end{lstlisting}

    \begin{lstlisting}
        if (number instanceof Integer i && Math.abs(i) == 0) // ok
        if (number instanceof Integer i || Math.abs(i) == 0) // i not defined
        if (number instanceof int i && Math.abs(i) == 0) // can't use primitives
    \end{lstlisting}

\subsection{Loops}

    for and while (but not do-while) don't need braces if just one statement follows.

    \begin{lstlisting}
        while (i<6) System.out.println("");
        for (;;) System.out.println();
    \end{lstlisting}

\section{Methods and functions}
\subsection{General notes}

    Java does not support setting default method parameter values.

\subsection{Pass-by-value and references}

    Java creates a copy of references and pass it to the invoked method,     but they still point to same memory reference. Thus, changes made to the object are reflected in the caller.

    \textit{However}, changes are not reflected back if we \textit{change the reference itself} to refer some other location or object!


\subsection{Method references}

    Method references cannot take parameters. Therefore, the output from the previous expression needs to match the input parameters of the referenced method signature.

    Types:
    \begin{itemize}
        \item Itatic method
        \item Instance method called on object \textit{instance}

            \begin{lstlisting}
                // No need to specify parameters explicitly if will get as many arguments as needed              createBicyclesList()
                    .stream()
                    .sorted(bikeFrameSizeComparator::compare);

                // equivalent to
                createBicyclesList()
                    .stream()
                    .sorted((a, b) -> bikeFrameSizeComparator.compare(a, b));
            \end{lstlisting}

        \item Instance method called on object \textit{type}

            \begin{lstlisting}
                // lambda way
                numbers.stream()
                    .sorted((a, b) -> a.compareTo(b))
                    .forEach(s -> System.out.print(s + " "));

                // method ref way
                numbers.stream()
                    .sorted(Integer::compareTo)
                    .forEach(s -> System.out.print(s + " "));
            \end{lstlisting}

        \item  constructor

            \begin{lstlisting}
                Bicycle[]::new
            \end{lstlisting}

    \end{itemize}

\subsection{Mixed notes on functions}
\subsubsection{compose()}

    The \lstinline{a.compose(b)} method calls the Function parameter b before the reference Function variable a.


\section{Classes, Interfaces, Records and Enums}
\subsection{General notes on inheritance}

    When a parent defines a with-arg constructor only, the child must call the parent constructor explicitly - it is not enough for both to take the same arguments.

    An instance variable with same name in the child hides the parent variable.

    When a parent method is static, the child cannot "override" (\textit{nor complement}) this by a same-arg instance method.

\subsection{Classes}
\subsubsection{Nested Classes}

    There are four types of nested classes: inner, static, local, and anonymous.
    Nested classes can be public.

    An \textit{inner} class requires an instance of the outer class to use.
    Three ways that are legal:

    \begin{lstlisting}
    public class Dinosaur {
        class Pterodactyl extends Dinosaur {}

        // it all happens in an instance method
        public void roar() {
            var dino = new Dinosaur();

            // uses instance to create inner
            dino.new Pterodactyl();

            // relies on the fact that roar() is an instance method
            //, which means there's an implicit instance of the outer class Dinosaur available
            new Dinosaur.Pterodactyl();

            // The Dinosaur. prefix is optional, though
            new Pterodactyl();
        } }
    \end{lstlisting}

    While a \textit{static} nested class does not:

    \begin{lstlisting}
        new Lion.Den()
    \end{lstlisting}

    A \textit{local} class is commonly defined within a method or block.
    Local classes can only access local variables that are final or effectively final.

    \textit{Anonymous} classes are a special type of local class that does not have a name.
    Anonymous classes are required to extend exactly one class or implement one interface.

    Note:

    \textit{Inner, local, and anonymous} classes can \textit{access private members} of the class in which they are defined, provided the latter two are used inside an instance method.

    \textit{All four} types of nested classes can now define static variables and methods.

\subsubsection{Sealed Classes}

    A sealed class is a class that restricts which other classes may directly extend it:

    \begin{lstlisting}
         sealed class Friendly extends Mandrill permits Silly {}
    \end{lstlisting}

    Parent and child must be in same package. If they are in same file or the extension is nested, no permits are needed.

    Every class that directly extends a sealed class must specify exactly one of the following three modifiers: final, sealed, or non-­sealed.

    Note:

    - We can have sealed interfaces (permitting both extensions and implementations).
    - While a sealed class is commonly extended by a subclass marked final, it can also be extended by a sealed or non-­sealed subclass marked abstract.

    \begin{lstlisting}
        // extends clause missing; it is Friendly that does not compile!
        sealed class Friendly extends Mandrill permits Silly {}
        final class Silly {}
    \end{lstlisting}
\subsubsection{Final and Immutable Classes}

    - Classes marked as final can’t be extended.
    - Immutable classes do not include setter methods. They must be marked final \textit{or} contain only private constructors.

\subsection{Interfaces}

    \textit{Variables} are always publics, static, final.

    \textit{Methods} can be either \textit{default} (these are always public), static (always public), private, or private and static. There are no protected members.

    \textit{Non-­static} metho47.3 concatenation:
    47.4 relativize():

    47.5 normalize

    47.6 : Resolves symbolic links. Normalizes path. Interacts with the file system - throws exception if not exists!
    - we have a symbolic link from /zebra to /horse.
    - current working directory is /horse/schedule
    ds with a body must be explicitly marked \textit{private} or \textit{default}.

    Note:

    - There is no modifier that can prevent a default method from being overridden in a class implementing an interface!

    - If implementing two interfaces with conflicting signatures, \textit{default} methods have to override it explicitly. They  can then access the inherited ones by calling Interface.super.method().

    - \textit{Static} methods are only accessible with a qualifier.

\subsection{Records}

    Minimal example:

    \begin{lstlisting}
        public record Crane(int numberEggs, String name) { }
    \end{lstlisting}

    Records may optionally have constructors.

    A (short) constructor (at most one):

    \begin{lstlisting}
        public Crane { // no parens
            if (numberEggs < 0) throw new IllegalArgumentException();
            name = name.toUpperCase();
            // long form is automatically called here
        }
    \end{lstlisting}

    A long constructor:

    \begin{lstlisting}
        public Crane(int numberEggs, String name) {
            if (numberEggs < 0) throw new IllegalArgumentException();
            this.numberEggs = numberEggs;
            this.name = name;
        }
    \end{lstlisting}

    Constructors may be overloaded:

    \begin{lstlisting}
        public record Crane(int numberEggs, String name) {
            public Crane(String firstName, String lastName) {
                // must be 1st call, must either call another constructor or the long constructor
                this(0, firstName + " " + lastName);
            }
        }
    \end{lstlisting}

    They can also implement interfaces:

    \begin{lstlisting}
        public record Crane(int numberEggs, String name) implements Bird {}
    \end{lstlisting}

    Overriding a method:

     \begin{lstlisting}
        public record BeardedDragon(boolean fun) {
            // overriding generated accessor
            @Override public boolean fun() { return false; }
        }
    \end{lstlisting}

    Records may be package access or public. They may contain methods, nested classes, interfaces, annotations, enums, and other records.

    Records can't be subclassed, since they are implicitly final.

    Records \textit{cannot} declare instance \textit{variables} (as opposed to instance \textit{methods}) or instance \textit{initializers}.

\subsection{Enums}

    Enums can have constructors, methods, and fields. Example:

        \begin{lstlisting}
        enum Flavors {
            VANILLA, CHOCOLATE, STRAWBERRY;
            static final Flavors DEFAULT = STRAWBERRY;
        }
    \end{lstlisting}

    Constructors are implicitly private. Example:

     \begin{lstlisting}
        enum Animals {
              // When an enum contains any other members, such as a constructor or variable, a semicolon is required:
            MAMMAL(true), INVERTEBRATE(Boolean.FALSE), BIRD(false),REPTILE(false),
            AMPHIBIAN(false), FISH(false) {public int swim() { return 4; }};

            final boolean hasHair;

            private Animals(boolean hasHair) {this.hasHair = hasHair;}

            public boolean hasHair() { return hasHair; }
            public int swim() { return 0; }
        }

    \end{lstlisting}

\subsection{Overriding, overloading and method hiding}
\subsubsection{Overloading}

    Overloading works also for pairs of primitive + wrapper, e.g.

    \begin{lstlisting}

        public static void main(String... args) {
            System.out.println(new App().woof(5)); // 1
            System.out.println(new App().woof(Integer.valueOf(5))); // 2
        }
        public String woof(int bark) {
            return "1";
        }
        public String woof(Integer bark) {
            return "2";
        }
    \end{lstlisting}

\subsubsection{Overriding}

    Overridden and hidden methods can only have covariant return types.
    This also applies to implementing abstract methods.

    When a parent method is private, no overriding takes place (so the child can do what it wants).

    Note:

    - Overriding replaces the method \textit{regardless of the reference type}.
    - There is no overriding of instance \textit{variables}! Instance variables are always determined based on the reference type!

    when parent defines a with-arg constructor only, child must call parent constructor
    explicitly (not enough for both to take the same args!)
    - instance variable with same name in child hides parent variable
    - when parent method is static, child cannot "override" (nor complement) this
    by same-arg instance method

\subsubsection{Method Hiding}

    When a child class defines a \textit{static method with the same signature} as a static method in the parent class, then the child’s method hides the one in the parent class.

    This is determined at \textit{compile} time, as opposed to overriding of instance methods, which is resolved at runtime.

\subsection{Class loading and initialization}
\subsubsection{Class}

    First, static variables are created, then static initializers are run.

    Static variables cannot access instance variables.

    If any static variable is final, it must be initialized.

\subsubsection{Instance}

    \textit{Instance initialization} blocks are invoked after the \textit{parent class constructor} has been invoked (i.e., after the super() constructor call).
    An instance initializer can also access any static variables.

    Beware: Variables newly created in the initializer block are in scope only there!

    If any instance variable is final, it must be initialized.

\subsubsection{Overall initialization order}

    \begin{enumerate}
        \item static variables in order
        \item static initializers in order
        \item instance variables in order
        \item call to \textit{parent class constructor}
        \item instance initializers in order
        \item local variables created in constructor
    \end{enumerate}

\section{Collections}

\subsection{Collections class}

    This class consists exclusively of static methods that operate on or return collections. It contains polymorphic algorithms that operate on collections, "wrappers", which return a new collection backed by a specified collection.

    Notes on methods:

    \begin{lstlisting}
        // Collections.binarySearch() returns index

    \end{lstlisting}

\subsection{Arrays class}

    This class contains various static methods for manipulating arrays (such as sorting and searching). This class also contains a static factory that allows arrays to be viewed as lists.

    Examples:

    \begin{lstlisting}
        Arrays.length()

        Arrays.binarySearch()

        // takes array or individual elements
        // eturns a fixed-size list backed by the specified array
        // size has to remain the same
        // hanges made to the array will be visible in the returned list,
        // and changes made to the list will be visible in the array
        Arrays.asList()
        // e. g.
        Integer[] numbers = [1,2,3];
        List<Integer> values = Arrays.asList(numbers);
        List<String> stooges = Arrays.asList("Larry", "Moe", "Curly");

        // takes two arrays and returns the index of the first item differing between the arrays.
        Arrays.mismatch()

        // compares every element in order, returns positive if first is bigger
        Arrays.compare()

    \end{lstlisting}


\subsection{List}

    \begin{lstlisting}
        // Collections.binarySearch() returns index

        // remove() is overloaded!
        // boolean remove(Object obj) removes an object that matches the parameter.
        // E remove(int index) removes (and returns) the element at the specified index.
        var list = new LinkedList<Integer>();
        list.add(3);
        list.add(2);
        list.add(1);
        list.remove(2); // int, index
        list.remove(Integer.valueOf(2)); //Integer, value

        // List.of(): returns an unmodifiable list containing an arbitrary number of elements.
        // can take individual elements or array
        List.of()

        // List.copyOf(): takes Collection and returns an immutable List
        static <E> List<E> copyOf(Collection<? extends E> coll)
        \end{lstlisting}


\subsubsection{ArrayList}




\subsection{Maps}

\subsection{Sets}

\subsection{Queues}

    Queue methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either null or false, depending on the operation).

    \begin{tabular}{|c|c|c|}
        \hline
        & Throws exception & Returns special value \\
        \hline
        Insert & add(e) & offer(e) \\
        \hline
        Remove & remove() & poll() \\
        \hline
        Examine & element() & peek() \\
        \hline
    \end{tabular}

    \begin{lstlisting}
        // --------------------- INSERTION ------------------------
        // inserts the specified element
        // returns true upon success, throws an IllegalStateException if no space is currently available
        boolean add(E e)

        // inserts the specified element
        // returns true if the element was added to this queue, else false
        boolean offer ()

        // --------------------- RETRIEVAL -------------------------
        // retrieves, but does not remove, the head of this queue
        // throws NoSuchElementException if this queue is empty
        E element()

        // retrieves, but does not remove, the head of this queue, or returns null if this queue is empty
        E peek()

        // --------------------- REMOVAL ---------------------------
        // retrieves and removes the head of this queue
        // throws NoSuchElementException if the queue is empty
        E remove()

        // retrieves and removes the head of this queue, or returns null if this queue is empty.
        E poll()
    \end{lstlisting}

\subsection{Deque}

    A linear collection that supports element insertion and removal at both ends.

    This interface defines methods to access the elements at both ends of the deque. Methods are provided to insert, remove, and examine the element. Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either null or false, depending on the operation).

    Methods overview:
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        &  & First Element (Head) &  & Last Element (Tail) \\
        \hline
        & Throws exception & Special value  & Throws exception & Special value  \\
        \hline
        Insert & addFirst(e) & offerFirst(e) & addLast(e) & offerLast(e) \\
        \hline
        &  &  &  &  \\
        \hline
        &  &  &  &  \\
        \hline
    \end{tabular}
    Summary of Deque methods:


    Remove 	removeFirst() 	pollFirst() 	removeLast() 	pollLast()
    Examine 	getFirst() 	peekFirst() 	getLast() 	peekLast()

    This interface extends the Queue interface. When a deque is used as a queue, FIFO (First-In-First-Out) behavior results. Elements are added at the end of the deque and removed from the beginning. The methods inherited from the Queue interface are precisely equivalent to Deque methods as indicated in the following table:
    Comparison of Queue and Deque methods Queue Method 	Equivalent Deque Method
    add(e) 	addLast(e)
    offer(e) 	offerLast(e)
    remove() 	removeFirst()
    poll() 	pollFirst()
    element() 	getFirst()
    peek() 	peekFirst()

    Deques can also be used as LIFO (Last-In-First-Out) stacks. This interface should be used in preference to the legacy Stack class. When a deque is used as a stack, elements are pushed and popped from the beginning of the deque. Stack methods are precisely equivalent to Deque methods as indicated in the table below:

    \begin{lstlisting}
        boolean 	add(E e)
        Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available.
        void 	addFirst(E e)
        Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available.
        void 	addLast(E e)
        Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available.
        boolean 	contains(Object o)
        Returns true if this deque contains the specified element.
        Iterator<E> 	descendingIterator()
        Returns an iterator over the elements in this deque in reverse sequential order.
        E 	element()
        Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque).
        E 	getFirst()
        Retrieves, but does not remove, the first element of this deque.
        E 	getLast()
        Retrieves, but does not remove, the last element of this deque.
        Iterator<E> 	iterator()
        Returns an iterator over the elements in this deque in proper sequence.
        boolean 	offer(E e)
        Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available.
        boolean 	offerFirst(E e)
        Inserts the specified element at the front of this deque unless it would violate capacity restrictions.
        boolean 	offerLast(E e)
        Inserts the specified element at the end of this deque unless it would violate capacity restrictions.
        E 	peek()
        Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty.
        E 	peekFirst()
        Retrieves, but does not remove, the first element of this deque, or returns null if this deque is empty.
        E 	peekLast()
        Retrieves, but does not remove, the last element of this deque, or returns null if this deque is empty.
        E 	poll()
        Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty.
        E 	pollFirst()
        Retrieves and removes the first element of this deque, or returns null if this deque is empty.
        E 	pollLast()
        Retrieves and removes the last element of this deque, or returns null if this deque is empty.
        E 	pop()
        Pops an element from the stack represented by this deque.
        void 	push(E e)
        Pushes an element onto the stack represented by this deque (in other words, at the head of this deque) if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available.
        E 	remove()
        Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque).
        boolean 	remove(Object o)
        Removes the first occurrence of the specified element from this deque.
        E 	removeFirst()
        Retrieves and removes the first element of this deque.
        boolean 	removeFirstOccurrence(Object o)
        Removes the first occurrence of the specified element from this deque.
        E 	removeLast()
        Retrieves and removes the last element of this deque.
        boolean 	removeLastOccurrence(Object o)
        Removes the last occurrence of the specified element from this deque.
        int 	size()
        Returns the number of elements in this deque.
    \end{lstlisting}

\begin{lstlisting}
\end{lstlisting}



\begin{lstlisting}
\end{lstlisting}


\begin{lstlisting}
\end{lstlisting}


\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}


\begin{lstlisting}
\end{lstlisting}


\begin{lstlisting}
\end{lstlisting}



\section{Generics}



\section{Streams, functional interfaces, and lambda functions}
\subsection{Lambda functions}

    Lambdas and method references use type inference.

    \begin{lstlisting}
        // does not compile
        var c4 = ArrayList::new;

        // nor does this:
        var dino = s -> "dino".equals(animal);
        var dragon = s -> "dragon".equals(animal);
        var combined = dino.or(dragon); // because var
    \end{lstlisting}

    Lambda expressions cannot redeclare any local variable defined in an enclosing scope.

    \begin{lstlisting}
        // does not compile
        var p = new Hyena();
        testLaugh(p, p -> true); // local variable already exists

        // nor does this:
        Set<?> s = Set.of("lion", "tiger", "bear");
        Consumer<Object> consumer = s -> s.forEach(consumer);
    \end{lstlisting}




\subsection{Functional interfaces}

    A valid functional interface is one that contains a single abstract method, excluding any public methods that are already defined in the java.lang.Object class.

    Beware: Types must match!

    \begin{lstlisting}
        @FunctionalInterface
        public interface Consumer<T> {
            void accept(T var1);
        }

        // So this will not compile:
        Consumer<Object> c2 = String::new; // there is no new String(object)
    \end{lstlisting}


    28.2
    28.3 the final modifier can only be used if a type or var is specified.
    - ok: Predicate<String> pred3 = (final var s) -­> s.isEmpty();
    - not ok: Predicate<String> pred2 = (final s) -­> s.isEmpty();
    28.4 NO: BiFunction<Integer,Integer,Integer> l = (Object w, var c) -> 39; // var cannot be mixed with non-var parameters
    28.5 (NO: a,b,c) -­> {int b = 3; return 2;} // cannot redeclare variable
    --> does not work in function either!!!
    void nothing(int g) {
        int g = 0;
    }
\subsection{Stream characteristics}
\subsubsection{Ordered}

    ORed values from: ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, SUBSIZED

    If the stream is parallel, and the Collector is concurrent,
    and either the stream is unordered or the collector is unordered,
    then a concurrent reduction will be performed.

    \begin{lstlisting}
        boolean isOrdered = stream.spliterator().hasCharacteristics(Spliterator.ORDERED);
    \end{lstlisting}

\subsection{Grouping/Collecting}

    Grouping operations return \textit{boxed} numbers, Map, Optional, ...

\subsubsection{Grouping vs. partitioning}

    \lstinline{groupingBy} creates a \lstinline{Map<K, List<T>>} as per the specified function, with optional \textit{downstream collector} and optional \textit{map type supplier}.

    \begin{lstlisting}
        groupingBy(Function f);
        groupingBy(Function f, Collector dc);
        groupingBy(Function f, Supplier s, Collector dc);
    \end{lstlisting}

    \lstinline{partitioningBy} creates a \lstinline{Map<Boolean, List<T>>} as per the specified predicate, with optional further downstream collector.
    Note: there is no map type specifier!

    \begin{lstlisting}
        partitioningBy(Predicate p);
        partitioningBy(Predicate p, Collector dc);
    \end{lstlisting}

\subsubsection{collect() with downstream collector: Collectors.toMap(), Collectors.toSet(), Collectors.counting(), Collectors.mapping()}

    \begin{lstlisting}
        var ohMy = Stream.of("lions", "tigers", "bears");
        Map<Integer, String> map = ohMy.collect(
            Collectors.toMap(
                String::length,
                k -> k,
                (s1, s2) -> s1 + "," + s2
            )
        );

        Map<Integer, Set<String>> map = ohMy.collect(
                Collectors.groupingBy(
                String::length,
                Collectors.toSet()
            )
        );

        Map<Integer, Long> map = ohMy.collect(
            Collectors.groupingBy(
                String::length,
                Collectors.counting()
            )
        );
        System.out.println(map); // {5=2, 6=1}

        // specifying map type
        TreeMap<Integer, Set<String>> map = ohMy.collect(
            Collectors.groupingBy(
                String::length,
                TreeMap::new,
                Collectors.toSet()
            )
        );

        // using another Collector in mapping
        Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
        Map<Integer, Optional<Character>> map = ohMy.collect(
            Collectors.groupingBy(
                String::length,
                Collectors.mapping(s -> s.charAt(0), Collectors.minBy((a, b) -> a-b))
            )
        );
        System.out.println(map); //{5=Optional[b], 6=Optional[t]}

        // teeing to return multiple results
        record Separations(String spaceSeparated, String commaSeparated) {}
        var list = List.of("x", "y", "z");
        Separations result = list.stream()
            .collect(Collectors.teeing(
                Collectors.joining(" "),
                Collectors.joining(","),
                (s, c) -> new Separations(s, c)
                )
             );
        // Separations[spaceSeparated=x y z, commaSeparated=x,y,z]

    \end{lstlisting}

\subsection{Comparing and sorting}

\subsubsection{Using Comparator}

    Comparator is a functional interface with one non-default method (besides equals()), compare():

    \begin{lstlisting}
        compare(T o1, T o2);
    \end{lstlisting}

    Comparator returns a negative integer if the first argument is smaller, zero if both are the same, or a positive integer if the first argument is bigger. I.e., if (a-b) is negative, then a ist smaller than b.

    \begin{lstlisting}
        // syntax note: compare
        // 1
        s.sorted(Comparator.reverseOrder())

        // 2
        s.sorted(Comparator::reverseOrder) // does not compile! Why?

        // sorted() takes a Comparator, i.e. a functional interface that takes 2 parameters and returns an int
        // while Comparator::reverseOrder is equivalent to (() -> Comparator.reverseOrder()), which is a Supplier<Comparator>
    \end{lstlisting}

\subsubsection{Using Comparable}

    Comparable is an interface with one method to be implemented, compareTo():

    \begin{lstlisting}
        public int compareTo(Sometype m)
    \end{lstlisting}

\subsection{Primitive streams}

    Primitive streams cannot take Double, Integer, etc. - there is no unboxing!

    The other way round, boxing does happen! See:

    \begin{lstlisting}
        // this works:
        IntFunction<Integer> f3 = s -> s; // int is boxed to Integer

        // this does not:
        IntFunction<Integer> f1 = (Integer f) -> f; // Integer is NOT unboxed to int
    \end{lstlisting}

\subsubsection{Optional types}

    Nearly all statistics operations on primitive streams return optional types.
    Only sum() returns 0.

    \begin{lstlisting}
        OptionalDouble opt = s.average()
        opt.getAsDouble() (may throw NoSuchElementException)

        27.5 IntSummaryStatistics etc.
        - getMax() etc. -> has get(), in contrast to that op on stream!
        27.6
    \end{lstlisting}

\subsubsection{Summary statistics}

    \begin{lstlisting}
       // note:
       // methods like getMax(), as opposed to max() on streams
    \end{lstlisting}

\subsection{Mapping, reducing, filtering}
\subsubsection{reduce()}

    If a combiner present, we get different results with parallel and serial streams.

    \begin{lstlisting}
        var data = List.of(1,2,3);
        int j = data.parallelStream().reduce(1, (a,b) -> a+b, (a,b) -> a+b); // 9
        int f = data.stream().reduce(1, (a,b) -> a+b, (a,b) -> a+b); // 7
    \end{lstlisting}

\subsubsection{flatmap()}

    E.g.,

    \begin{lstlisting}
        integerList.stream().flatMapToInt(x -> IntStream.of(x))
        integerList.stream().flatMapToDouble(x -> DoubleStream.of(x))
    \end{lstlisting}

\subsubsection{Mapping primitive streams to object streams or primitive streams}

    Examples:

    \begin{lstlisting}
        // analogously for IntStream, LongStream
        DoubleStream -> map() -> DoubleStream

        // analogously for IntStream, LongStream
        DoubleStream ->mapToObj()-> Stream<T>

    \end{lstlisting}

    Re. mapping functions:

    \begin{lstlisting}
        // generic to all generic (no primitives involved): takes Function<T,R>

        // generic to primitive:
        ToDoubleFunction<T>, ToIntFunction<T>, ToLongFunction<T>

        // primitive to primitive:
        // e.g.

        // DoubleStream -> map()-> generic: takes
        DoubleFunction<R>

        // DoubleStream -> mapToDouble()-> DoubleStream takes:
        DoubleUnaryOperator

        // DoubleStream -> mapToInt()-> IntStream: takes
        DoubleToIntFunction

        // DoubleStream -> mapToLong() -> LongStream takes:
            DoubleToLongFunction

        // IntStream -> map[...]() -> generic/Int/Long/Double-Stream takes:
        IntFunction<R>, IntUnaryOperator, IntToLongFunction, IntToDoubleFunction

        // LongStream -> map[...]() -> generic/Int/Long/Double-Stream takes:
        LongFunction<R>, LongUnaryOperator, LongToIntFunction, LongToDoubleFunction

        // DoubleStream -> map[...]*( )-> generic/Int/Long/Double-Stream: takes
        DoubleFunction<R>, DoubleUnaryOperator, DoubleToIntFunction, DoubleToLongFunction
    \end{lstlisting}

\subsubsection{Chaining operations}

    E.g., andThen():

    \begin{lstlisting}
        // andThen: for Consumer and Function
        // Returns a composed BiConsumer that performs, in sequence, this operation followed by the after operation.
        default BiConsumer<T,U> andThen BiConsumer<? super T, ? super U> after
    \end{lstlisting}

\subsection{Splitting up streams with Spliterator}

    \begin{lstlisting}
        var stream = List.of("bird-", "bunny-", "cat-", "dog-", "fish-", "lamb-", "mouse-");
        Spliterator<String> originalBagOfFood = stream.spliterator();

        // has the ones at the beginning
        Spliterator<String> emmasBag = originalBagOfFood.trySplit();

        // bird-bunny-cat
        emmasBag.forEachRemaining(System.out::print);

        // original now has the 4 ones at the end, jill gets dog and fish
        Spliterator<String> jillsBag = originalBagOfFood.trySplit();

        // dog-
        // advance gets the first and removes it
        jillsBag.tryAdvance(System.out::print);

        // fish-
        jillsBag.forEachRemaining
        (System.out::print);

        // lamb-mouse
        originalBagOfFood.forEachRemaining(System.out::print);
    \end{lstlisting}

\section{IO}
\subsection{java.io}
\subsubsection{Serialization}

    To be serializable, a class must implement the Serializable marker interface.
    All members must either be serializable, as well, or must be declared transient (otherwise
    a NotSerializableException is thrown).

    Methods and the exceptions they throw:

    \begin{lstlisting}
        // ObjectInputStream
        public Object readObject() throws IOException, ClassNotFoundException

        // ObjectOutputStream
        public void writeObject(Object obj) throws IOException
    \end{lstlisting}

    On deserialization, the constructor and any instance initializers \textit{not} called.
    Instead, Java will call the \textit{no-­arg constructor of the first non-serializable parent class} it can find in the class hierarchy.

    Static (!) as well as transient fields are ignored.

    Values that are not provided are  given their default Java value, such as null for String, or 0 for int values.

    To read several objects from a file, we need to use an infinite loop to process the data,
    which throws an EOFException when the end of the I/O stream is reached. That's because, when calling readObject(), null and -­1 do not have any special meaning,
    as someone might have serialized objects with those values.

    \begin{lstlisting}
        var gorillas = new ArrayList<Gorilla>();
        try (var in = new ObjectInputStream(new BufferedInputStream(new FileInputStream(dataFile)))) {
            while (true) {
                var object = in.readObject();
                if (object instanceof Gorilla g)
                gorillas.add(g);
            }
        } catch (EOFException e) { // File end reached
        }
        return go
    \end{lstlisting}

\subsubsection{Abstract base classes}

    InputStream, OutputStream, Reader, Writer.

    Beware: these are abstract classes, not interfaces!

\subsubsection{Byte Streams}

    Classes: FileInputStream, FileOutputStream, BufferedInputStream (readAllBytes), BufferedOutputStream, PrintStream.

    PrintStream methods: append(byte b),..., format(Locale l, String format, Object... args), void print(boolean b),...

\subsubsection{Character Streams}

    FileReader, FileWriter, BufferedReader (readLine), BufferedWriter (write (line), newLine), PrintWriter.

    PrintWriter methods: append(char c),..., format(Locale l, String format, Object... args), void print(boolean b),...

    Beware: As opposed to BufferedInputStream, Buffered Reader does not have a method to read all lines!

\subsubsection{Console}

    \begin{lstlisting}
        // to obtain (constructor is private)
        Console console = System.console();

        // always check that console is not null
        Console console = System.console();
        if (console != null)  String userInput = console.readLine();

        // fields e.g.
        Reader, Writer, PrintWriter

        // methods e.g.
        reader()
        readLine() - this we wouldn't get from the Reader field!
        // NOT: read() - we have to get the Reader first
        reader.read()
    \end{lstlisting}

\subsubsection{Using mark()}

    \begin{lstlisting}
        // methods
        public boolean markSupported()

        // readLimit: instructs the I/O stream that we expect to call reset() after at most readLimit bytes.
        // If our program calls reset() after reading more than 100 bytes from calling mark(readLimit), it may throw an exception, depending on the I/O stream class.
        public void mark(int readLimit)

        public void reset() throws IOException

        // returns number of values skipped
        public long skip(long n) throws IOException

        // how to use
        public void readData(InputStream is) throws IOException {
            System.out.print((char) is.read()); // L

            if (is.markSupported()) {

            is.mark(100); // Marks up to 100 bytes
            System.out.print((char) is.read()); // I
            System.out.print((char) is.read()); // O
            is.reset(); // Resets stream to position before I
            }
            System.out.print((char) is.read()); // I
            System.out.print((char) is.read()); // O
            System.out.print((char) is.read()); // N
        }
    \end{lstlisting}



\subsection{java.nio}

\subsubsection{Constructing a path: Path.of, Paths.get}

    \begin{lstlisting}
        Path zooPath1 = Path.of("/home/tiger/data/stripes.txt");
        Path zooPath2 = Path.of("/home", "tiger", "data", "stripes.txt");

        Path zooPath3 = Paths.get("/home/tiger/data/stripes.txt");
        Path zooPath4 = Paths.get("/home", "tiger", "data", "stripes.txt");
    \end{lstlisting}

\subsubsection{Conversion to or back from java.io.File}

    \begin{lstlisting}
        File file = new File("rabbit");
        Path nowPath = file.toPath();
        File backToFile = nowPath.toFile();
    \end{lstlisting}

\subsubsection{Concatenation: Path resolve(Path other)}

    Resolves the given path against this path. Does not normalize!

    \begin{lstlisting}
        // the input argument is appended onto the Path, e.g.

        // with input a relative path:
        Path path1 = Path.of("/cats/../panther");
        Path path2 = Path.of("food");
        System.out.println(path1.resolve(path2));
        // /cats/../panther/food

        // if input is absolute, return input
        Path path3 = Path.of("/turkey/food");
        path3.resolve("/tiger/cage");
        // /turkey/food
    \end{lstlisting}

\subsubsection{Constructing a relative path: Path relativize(Path other)}

    \begin{lstlisting}
        //requires that both path values be absolute or relative
        // otherwise, an exception is produced at runtime
        var path1 = Path.of("fish.txt");
        var path2 = Path.of("friendly/birds.txt");
        path1.relativize(path2);
        // ../friendly/birds.txt

        // Note: the file itself counts as one level!
        path2.relativize(path1);
        // ../../fish.txt
        // => go up "plus 1"

        // Relativization is the inverse of resolution.
        // For any two normalized paths p and q, where q does not have a root component, we have
        p.relativize(p.resolve(q)).equals(q)
    \end{lstlisting}


\subsubsection{toAbsolutePath}

    Resolves the path in an implementation dependent manner, typically by resolving the path against a file system default directory.
    For me, the current working directory is picked, and transformed to absolute.

\subsubsection{Normalizing a path: normalize}

    \begin{lstlisting}
        var p1 = Paths.get("/pony/../weather.txt");
        var p2 = Paths.get("/weather.txt");
        p1.equals(p2); // false
        p1.normalize().equals(p2.normalize()); // true
    \end{lstlisting}

\subsubsection{Resolve symlinks: toRealPath}

    \begin{lstlisting}
        ll horse/
        schedule/
        food.txt

        ll zebra/
        schedule/
        food.txt

        Paths.get("/zebra/food.txt").toRealPath(); // /horse/food.txt
        Paths.get(".././food.txt").toRealPath());  // same -- normalizes
    \end{lstlisting}

\subsubsection{Copying files: copy}

    \begin{lstlisting}
        // copy from file to file
        Files.copy(Paths.get("book.txt"), Paths.get("movie.txt"), StandardCopyOption.REPLACE_EXISTING);
        // copy from stream to file
        try (var is = new FileInputStream("source-data.txt")) {
            Files.copy(is, Paths.get("/mammals/wolf.txt"));
        }
        // copy from file to stream
        Files.copy(Paths.get("/fish/clown.xsl"), System.out);

        // copy a file into a directory
        var file = Paths.get("food.txt");
        var directory = Paths.get("/enclosure/food.txt"); // NOT /enclosure!
        Files.copy(file, directory);
    \end{lstlisting}

\subsubsection{Comparing file content: isSameFile() and mismatch()}
    isSameFile() uses equals (maybe having to normalize).

    mismatch() returns -1 if the files are the same; otherwise, it returns the index of the first position in the file that differs.

\subsubsection{Reading files}

    \begin{lstlisting}
        // reads the entire file into memory
        // returns List<String>
        Files.readAllLines(Paths.get("birds.txt"))
            .forEach(System.out::println);

        // reads lazily
        // returns Stream<String>
        Files.lines(Paths.get("birds.txt"))
            .forEach(System.out::println);
    \end{lstlisting}

\subsubsection{java.nio.Files methods}

    e.g.,

    \begin{itemize}
        \item creation: createDirectories, createSymbolicLink, ...
        \item deletion: deleteIfExists, delete, ...
        \item other: newBufferedWriter, ...
        \item retrieve attributes: isDirectory, isRegularFile, isSymbolicLink,
            isHidden(), isReadable(), isWriteable(), isExecutable()
    \end{itemize}


    \begin{lstlisting}
        // find
        Stream<Path> find(Path start, int maxDepth, BiPredicate<Path, BasicFileAttributes> matcher, FileVisitOption... options) throws IOException

        // walk
        public static Stream<Path> walk(Path start, int maxDepth, FileVisitOption... options) throws IOException
    \end{lstlisting}

\subsubsection{Using views for attribute retrieval}

    A view is a group of related attributes for a particular file system type.

    \begin{lstlisting}
        public static <A extends BasicFileAttributes> A readAttributes(
            Path path,
            Class<A> type,
            LinkOption... options
        ) throws IOException

        var path = Paths.get("/turtles/sea.txt");  // needs a Path!
        BasicFileAttributes data = Files.readAttributes(path, BasicFileAttributes.class);
        System.out.println("Is a directory? " + data.isDirectory());
        System.out.println("Is a regular file? " + data.isRegularFile());
        System.out.println("Is a symbolic link? " + data.isSymbolicLink());
        System.out.println("Size (in bytes): " + data.size()); // not length()!
        System.out.println("Last modified: " + data.lastModifiedTime());
    \end{lstlisting}

    To modify attributes, use BasicFileAttributeView, not BasicFileAttributes:

    \begin{lstlisting}
        public static <V extends FileAttributeView> V getFileAttributeView(
            Path path,
            Class<V> type,
            LinkOption... options
        ) throws IOException

        // step 1: Read file attributes, using BasicFileAttributeView
        var path = Paths.get("/turtles/sea.txt");
        // this uses BasicFileAttributeView, NOT BasicFileAttributes
        BasicFileAttributeView view = Files.getFileAttributeView(path,
        BasicFileAttributeView.class);
        BasicFileAttributes attributes = view.readAttributes();

        // step 2: Modify file last modified time
        FileTime lastModifiedTime = FileTime.fromMillis(attributes.lastModifiedTime().toMillis() + 10_000);
        // BasicFileAttributeView instance method
        //public void setTimes(FileTime lastModifiedTime,
        //FileTime lastAccessTime, FileTime createTime)
        view.setTimes(lastModifiedTime, null, null);
    \end{lstlisting}



    \begin{lstlisting}



    \end{lstlisting}

    \begin{lstlisting}

    \end{lstlisting}

    \begin{lstlisting}

    \end{lstlisting}

    \begin{lstlisting}

    \end{lstlisting}

\subsubsection{Common method arguments}

    \begin{lstlisting}

        // Enums implementing (empty) interfaces, e.g.
        public enum StandardCopyOption implements CopyOption {
            REPLACE_EXISTING,
            COPY_ATTRIBUTES,
            ATOMIC_MOVE;
            private StandardCopyOption() {}}

    \end{lstlisting}

\section{Exception handling}
\subsection{try-with-resources}

    Only classes that implement the AutoCloseable interface can be used in a try-with-resources statement.

    Resources are closed in reverse order of how they were created.

    Resources can be declared in advance, provided they are final or effectively final.

    \begin{lstlisting}
        // simple syntax
        try (FileInputStream is = new FileInputStream("myfile.txt")) {}

        // if we have several resources, a semicolon between them is needed
        try (
            var in = new FileInputStream("data.txt");
             // the one at the end is optional
            var out = new FileOutputStream("output.txt");) {}
    \end{lstlisting}

    If the close() method also throws an exception, this is added as \textit{suppressed}. In other words: If exceptions are thrown from both the try block and the try-with-resources statement,
    the exception from the try block thrown; the exception thrown from the try-with-resources block is added as suppressed.

    Example:
    \begin{lstlisting}
        public class JammedTurkeyCage implements AutoCloseable {

            public void close() throws IllegalStateException {
                throw new IllegalStateException("Cage door does not close");
            }

            public static void main(String[] args) {
                try (JammedTurkeyCage t = new JammedTurkeyCage()) {
                    // primary
                    throw new IllegalStateException("Turkeys ran off");
                    // here close is called, we get an IllegalStateException
                    // this is added as suppressed
                } catch (IllegalStateException e) {
                    // primary
                    System.out.println("Caught: " + e.getMessage());
                    for (Throwable t: e.getSuppressed())
                    // the one from close()
                    System.out.println("Suppressed: "+t.getMessage());
        }}}
        // Output
        // Caught: Turkeys ran off
        // Suppressed: Cage door does not close
    \end{lstlisting}

    Another example:
    \begin{lstlisting}
        try (JammedTurkeyCage t = new JammedTurkeyCage()) {
            // primary exception
            // not caught
            throw new RuntimeException("Turkeys ran off");
            // close is called, get IllegalStateException
            // this is added as suppressed
        } catch (IllegalStateException e) {
            System.out.println("caught: " + e.getMessage());
            for (Throwable t: e.getSuppressed())
                // the one from close()
                System.out.println("Suppressed: "+t.getMessage());
        }
        // Output
        // Exception in thread "main" java.lang.RuntimeException: // Turkeys ran off
        // Suppressed: java.lang.IllegalStateException:Cage door does not close
    \end{lstlisting}

    Note: Programmer-provided catch and final blocks are run after automatic ones.

\section{Internationalization}
\subsection{Resource bundles}

    Once a resource bundle has been selected, only properties along a \textit{single hierarchy} will be used.

\section{Concurrency}
\subsection{Thread states}

    Note: Calling interrupt()
    on a thread in the TIMED\_WAITING or WAITING states causes the main() thread to become RUNNABLE again, triggering an InterruptedException.

    Calling interrupt() on a thread already in a RUNNABLE state doesn’t change the state.

\subsection{Interface Runnable}
    \begin{lstlisting}
        // def.
        @FunctionalInterface public interface Runnable {void run();}

        // to start, call start, not run
        new Thread(() -> System.out.print("Hello")).start();

        // example
        Runnable printInventory = () -> System.out.println("Printing zoo inventory");
        new Thread(printInventory).start();
    \end{lstlisting}


\subsection{Interface Callable}

    \begin{lstlisting}
        // def.
        @FunctionalInterface public interface Callable<V> {V call() throws Exception;}
    \end{lstlisting}

\subsection{Concurrency API}

    \begin{lstlisting}
        ExecutorService service = Executors.newSingleThreadExecutor();
        try {
            service.execute(printInventory);
        } finally {
            // doesn't implement AutoCloseable!
            service.shutdown();
        }

        // isShutdown() -- no longer accepts new
        // isTerminated() -- is shut down

        service.awaitTermination(1, TimeUnit.MINUTES); // after shutdown


    \end{lstlisting}

    Comparing execute() and submit(). Excute():

    \begin{lstlisting}

        // def.
        void execute(Runnable command)	/ no returns!

    \end{lstlisting}

    Submit():
    \begin{lstlisting}

        // def.
        // pass Runnable, get Future
        Future<?> submit(Runnable task)

        // pass Callable<T>, get Future<T>
        <T> Future<T> submit(Callable<T> task)

        // pass collection of Callables
        // waits for all tasks to complete
        <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)

        // pass collection of Callables
        // waits for at least one task to complete
        <T> T invokeAny(Collection<? extends Callable<T>> tasks)

        // get result
        // for Runnable: always null!
        ExecutorService service = Executors.newSingleThreadExecutor();
        try {
            Future<?> result = service.submit(() -> {
                for(int i = 0; i < 1_000_000; i++) counter++;
            });
            // Returns null for Runnable!
            result.get(10, TimeUnit.SECONDS);
            System.out.println("Reached!");
        } catch (TimeoutException e) {
            System.out.println("Not reached in time");
        } finally {
            service.shutdown();
        }}

        // for Callable, this returns something
        try {
            Future<Integer> result = service.submit(() -> 30 + 11);
            System.out.println(result.get());
        }
    \end{lstlisting}

\subsection{volatile}

    Ensures that only one thread is modifying a variable at one time and that data read among multiple threads is consistent.
    But operations are not atomic!

\end{document}

